<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Naval Battle - Single Player</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            overflow: auto;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #1a1a2e;
            min-height: 800px;
        }
        
        #gameCanvas {
            border: 2px solid #16213e;
            background: #0f3460;
            cursor: crosshair;
            max-width: 95vw;
            max-height: 70vh;
        }
        
        #topScore {
            display: flex;
            justify-content: space-between;
            width: min(1004px, 95vw);
            margin-bottom: 5px;
            font-size: 14px;
            color: white;
        }
        
        #singlePlayerControls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            color: white;
            text-align: center;
        }
        
        #controlsToggle {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 100;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #16213e;
            color: white;
            cursor: pointer;
        }
        
        #controlsPanel {
            position: absolute;
            left: 10px;
            bottom: 60px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #16213e;
            border-radius: 8px;
            padding: 15px;
            color: white;
            font-size: 14px;
            line-height: 1.4;
            max-width: 300px;
            z-index: 99;
        }
        
        #controlsPanel.hidden {
            display: none;
        }
        
        .score-item {
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .team1-score {
            color: #4169E1;
        }
        
        .team2-score {
            color: #DC143C;
        }
        
        .game-info {
            color: #ccc;
        }
        
        button {
            padding: 8px 16px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background: #4169E1;
            color: white;
            cursor: pointer;
        }
        
        button:hover {
            background: #5a7ae6;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="topScore">
            <div class="score-item team1-score">
                Player: <span id="playerScore">0</span>
            </div>
            <div class="score-item game-info">
                <span id="selectedShip">No Ship Selected</span> | Time: <span id="gameTime">0:00</span>
            </div>
            <div class="score-item team2-score">
                AI: <span id="aiScore">0</span>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        
        <div id="singlePlayerControls">
            <div><strong>Single Player</strong></div>
            <button id="menuBtn" onclick="window.location.href='/'">← Main Menu</button>
            <button id="startBtn" onclick="game.startGame()">Start Game</button>
        </div>
        
        <button id="controlsToggle">Controls</button>
        
        <div id="controlsPanel" class="hidden">
            <div><strong>Controls:</strong></div>
            <div>• <strong>Q/E:</strong> Cycle through ships</div>
            <div>• <strong>1-5:</strong> Select specific ship</div>
            <div>• <strong>W/S:</strong> Adjust speed</div>
            <div>• <strong>A/D:</strong> Steer left/right</div>
            <div>• <strong>Mouse:</strong> Aim cannons</div>
            <div>• <strong>Space:</strong> Fire cannon</div>
            <div>• Blue ships are yours, red are AI</div>
        </div>
    </div>

    <script>
        class SinglePlayerGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameState = {
                    ships: [],
                    cannonballs: [],
                    obstacles: [],
                    scores: { player: 0, ai: 0 },
                    gameStarted: false,
                    gameStartTime: null
                };
                this.selectedShipId = null;
                this.selectedShipIndex = 0;
                this.keys = {};
                this.mouseAimAngle = 0;
                this.nextShipId = 1;
                this.nextCannonballId = 1;
                
                this.setupEventListeners();
                this.generateObstacles();
                this.startGameLoop();
            }
            
            setupEventListeners() {
                // Canvas events
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                
                // Keyboard events
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    this.handleKeyPress(e);
                });
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // Controls toggle
                document.getElementById('controlsToggle').addEventListener('click', () => {
                    const panel = document.getElementById('controlsPanel');
                    panel.classList.toggle('hidden');
                });
            }
            
            generateObstacles() {
                // Islands
                for (let i = 0; i < 2; i++) {
                    this.gameState.obstacles.push({
                        id: `island_${i}`,
                        type: 'island',
                        x: 250 + Math.random() * 500,
                        y: 150 + Math.random() * 400,
                        radius: 30 + Math.random() * 20,
                        destructible: false
                    });
                }
                
                // Icebergs
                for (let i = 0; i < 3; i++) {
                    this.gameState.obstacles.push({
                        id: `iceberg_${i}`,
                        type: 'iceberg',
                        x: 150 + Math.random() * 700,
                        y: 100 + Math.random() * 500,
                        radius: 20 + Math.random() * 15,
                        destructible: true,
                        health: 3
                    });
                }
            }
            
            startGame() {
                this.gameState.gameStarted = true;
                this.gameState.gameStartTime = Date.now();
                
                // Spawn player ships (blue)
                for (let i = 0; i < 5; i++) {
                    this.spawnShip('player', 'team1', { x: 100, y: 620 });
                }
                
                // Spawn AI ships (red)  
                for (let i = 0; i < 5; i++) {
                    this.spawnShip('ai', 'team2', { x: 900, y: 80 });
                }
                
                document.getElementById('startBtn').style.display = 'none';
            }
            
            spawnShip(owner, team, spawnPoint) {
                const angle = team === 'team1' ? -45 * Math.PI/180 : 135 * Math.PI/180;
                const ship = {
                    id: `ship_${this.nextShipId++}`,
                    owner: owner,
                    team: team,
                    x: spawnPoint.x + (Math.random() - 0.5) * 60,
                    y: spawnPoint.y + (Math.random() - 0.5) * 60,
                    angle: angle,
                    rudderAngle: 0,
                    targetRudderAngle: 0,
                    cannonAngle: angle,
                    speed: 25,
                    health: 3,
                    maxHealth: 3,
                    lastShot: Date.now(),
                    shotCooldown: 3000,
                    spawnTime: Date.now()
                };
                
                this.gameState.ships.push(ship);
                
                // Select first player ship
                if (owner === 'player' && !this.selectedShipId) {
                    this.selectedShipId = ship.id;
                }
            }
            
            handleCanvasClick(e) {
                if (!this.gameState.gameStarted) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                // Find clicked ship
                for (const ship of this.gameState.ships) {
                    if (ship.owner === 'player') {
                        const dx = x - ship.x;
                        const dy = y - ship.y;
                        if (Math.sqrt(dx*dx + dy*dy) < 20) {
                            this.selectedShipId = ship.id;
                            this.updateSelectedShipIndex();
                            return;
                        }
                    }
                }
            }
            
            handleMouseMove(e) {
                if (!this.selectedShipId) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                const selectedShip = this.gameState.ships.find(s => s.id === this.selectedShipId);
                if (selectedShip) {
                    this.mouseAimAngle = Math.atan2(y - selectedShip.y, x - selectedShip.x);
                    selectedShip.cannonAngle = this.mouseAimAngle;
                }
            }
            
            handleKeyPress(e) {
                if (!this.gameState.gameStarted) return;
                
                const key = e.key.toLowerCase();
                
                // Ship selection
                if (key >= '1' && key <= '5') {
                    const shipIndex = parseInt(key) - 1;
                    const playerShips = this.gameState.ships.filter(s => s.owner === 'player');
                    if (playerShips[shipIndex]) {
                        this.selectedShipId = playerShips[shipIndex].id;
                        this.selectedShipIndex = shipIndex;
                    }
                }
                
                if (key === 'q' || key === 'e') {
                    this.cycleSelectedShip(key === 'e' ? 1 : -1);
                }
                
                if (key === ' ') {
                    e.preventDefault();
                    this.fireSelectedShip();
                }
            }
            
            cycleSelectedShip(direction) {
                const playerShips = this.gameState.ships.filter(s => s.owner === 'player');
                if (playerShips.length === 0) return;
                
                this.selectedShipIndex = (this.selectedShipIndex + direction + playerShips.length) % playerShips.length;
                this.selectedShipId = playerShips[this.selectedShipIndex].id;
            }
            
            updateSelectedShipIndex() {
                const playerShips = this.gameState.ships.filter(s => s.owner === 'player');
                this.selectedShipIndex = playerShips.findIndex(s => s.id === this.selectedShipId);
            }
            
            fireSelectedShip() {
                const ship = this.gameState.ships.find(s => s.id === this.selectedShipId);
                if (ship && Date.now() - ship.lastShot >= ship.shotCooldown) {
                    this.fireCannonball(ship);
                }
            }
            
            fireCannonball(ship) {
                const cannonball = {
                    id: `cannonball_${this.nextCannonballId++}`,
                    shooterId: ship.id,
                    shooterTeam: ship.team,
                    x: ship.x + Math.cos(ship.cannonAngle) * 25,
                    y: ship.y + Math.sin(ship.cannonAngle) * 25,
                    angle: ship.cannonAngle,
                    speed: 150
                };
                
                this.gameState.cannonballs.push(cannonball);
                ship.lastShot = Date.now();
            }
            
            update(deltaTime) {
                if (!this.gameState.gameStarted) return;
                
                // Update ships
                for (const ship of this.gameState.ships) {
                    if (ship.owner === 'player') {
                        this.updatePlayerShip(ship, deltaTime);
                    } else {
                        this.updateAIShip(ship, deltaTime);
                    }
                    
                    this.updateShipMovement(ship, deltaTime);
                    this.handleShipBoundaries(ship);
                    
                    // Auto-fire for AI ships
                    if (ship.owner === 'ai' && Date.now() - ship.lastShot >= ship.shotCooldown) {
                        const target = this.findNearestTarget(ship);
                        if (target) {
                            ship.cannonAngle = Math.atan2(target.y - ship.y, target.x - ship.x);
                            this.fireCannonball(ship);
                        }
                    }
                }
                
                // Update cannonballs
                for (const cannonball of this.gameState.cannonballs) {
                    cannonball.x += Math.cos(cannonball.angle) * cannonball.speed * deltaTime;
                    cannonball.y += Math.sin(cannonball.angle) * cannonball.speed * deltaTime;
                    
                    // Remove out of bounds
                    if (cannonball.x < -10 || cannonball.x > 1010 || 
                        cannonball.y < -10 || cannonball.y > 710) {
                        cannonball.dead = true;
                    }
                }
                
                this.checkCollisions();
                this.cleanupDeadObjects();
                this.updateUI();
            }
            
            updatePlayerShip(ship, deltaTime) {
                if (ship.id !== this.selectedShipId) return;
                
                // Steering
                if (this.keys['a']) ship.targetRudderAngle = -Math.PI/4;
                else if (this.keys['d']) ship.targetRudderAngle = Math.PI/4;
                else ship.targetRudderAngle = 0;
                
                // Speed control
                if (this.keys['w']) ship.speed = Math.min(50, ship.speed + 30 * deltaTime);
                if (this.keys['s']) ship.speed = Math.max(0, ship.speed - 30 * deltaTime);
            }
            
            updateAIShip(ship, deltaTime) {
                // Simple AI - find nearest player ship and chase
                const target = this.findNearestTarget(ship);
                if (target) {
                    const dx = target.x - ship.x;
                    const dy = target.y - ship.y;
                    const targetAngle = Math.atan2(dy, dx);
                    
                    let angleDiff = targetAngle - ship.angle;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    ship.targetRudderAngle = Math.sign(angleDiff) * Math.PI/6;
                }
            }
            
            findNearestTarget(ship) {
                const enemyTeam = ship.team === 'team1' ? 'team2' : 'team1';
                const enemies = this.gameState.ships.filter(s => s.team === enemyTeam);
                
                let nearest = null;
                let minDistance = Infinity;
                
                for (const enemy of enemies) {
                    const dx = enemy.x - ship.x;
                    const dy = enemy.y - ship.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = enemy;
                    }
                }
                
                return nearest;
            }
            
            updateShipMovement(ship, deltaTime) {
                // Update rudder
                const rudderSpeed = 2.0;
                const rudderDiff = ship.targetRudderAngle - ship.rudderAngle;
                ship.rudderAngle += Math.sign(rudderDiff) * Math.min(Math.abs(rudderDiff), rudderSpeed * deltaTime);
                
                // Update angle and position
                const turnRate = 0.8;
                ship.angle += ship.rudderAngle * turnRate * deltaTime;
                
                ship.x += Math.cos(ship.angle) * ship.speed * deltaTime;
                ship.y += Math.sin(ship.angle) * ship.speed * deltaTime;
            }
            
            handleShipBoundaries(ship) {
                if (ship.x < 0 || ship.x > 1000) {
                    ship.x = Math.max(0, Math.min(1000, ship.x));
                    ship.angle = Math.PI - ship.angle;
                    ship.rudderAngle = 0;
                    ship.targetRudderAngle = 0;
                }
                
                if (ship.y < 0 || ship.y > 700) {
                    ship.y = Math.max(0, Math.min(700, ship.y));
                    ship.angle = -ship.angle;
                    ship.rudderAngle = 0;
                    ship.targetRudderAngle = 0;
                }
            }
            
            checkCollisions() {
                // Ship-obstacle collisions
                for (const ship of this.gameState.ships) {
                    for (const obstacle of this.gameState.obstacles) {
                        const dx = ship.x - obstacle.x;
                        const dy = ship.y - obstacle.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < obstacle.radius + 12) {
                            ship.health -= 0.01;
                            const pushX = (dx / distance) * 2;
                            const pushY = (dy / distance) * 2;
                            ship.x += pushX;
                            ship.y += pushY;
                        }
                    }
                }
                
                // Cannonball-ship collisions
                for (const cannonball of this.gameState.cannonballs) {
                    for (const ship of this.gameState.ships) {
                        if (cannonball.shooterTeam === ship.team) continue;
                        
                        const dx = cannonball.x - ship.x;
                        const dy = cannonball.y - ship.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < 15) {
                            cannonball.dead = true;
                            ship.health -= 1;
                            
                            if (ship.health <= 0) {
                                const scoreKey = cannonball.shooterTeam === 'team1' ? 'player' : 'ai';
                                this.gameState.scores[scoreKey]++;
                                
                                // Respawn after delay
                                setTimeout(() => {
                                    if (this.gameState.gameStarted) {
                                        const spawnPoint = ship.team === 'team1' ? 
                                            { x: 100, y: 620 } : { x: 900, y: 80 };
                                        this.spawnShip(ship.owner, ship.team, spawnPoint);
                                    }
                                }, 3000);
                                
                                ship.dead = true;
                            }
                        }
                    }
                }
                
                // Cannonball-obstacle collisions
                for (const cannonball of this.gameState.cannonballs) {
                    for (const obstacle of this.gameState.obstacles) {
                        const dx = cannonball.x - obstacle.x;
                        const dy = cannonball.y - obstacle.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < obstacle.radius + 3) {
                            cannonball.dead = true;
                            
                            if (obstacle.destructible) {
                                obstacle.health--;
                                obstacle.radius -= 5;
                                if (obstacle.health <= 0 || obstacle.radius <= 10) {
                                    obstacle.dead = true;
                                }
                            }
                        }
                    }
                }
            }
            
            cleanupDeadObjects() {
                this.gameState.ships = this.gameState.ships.filter(s => !s.dead && s.health > 0);
                this.gameState.cannonballs = this.gameState.cannonballs.filter(c => !c.dead);
                this.gameState.obstacles = this.gameState.obstacles.filter(o => !o.dead);
                
                // Update selected ship if it's dead
                if (this.selectedShipId && !this.gameState.ships.find(s => s.id === this.selectedShipId)) {
                    const playerShips = this.gameState.ships.filter(s => s.owner === 'player');
                    this.selectedShipId = playerShips[0]?.id || null;
                    this.selectedShipIndex = 0;
                }
            }
            
            updateUI() {
                document.getElementById('playerScore').textContent = this.gameState.scores.player;
                document.getElementById('aiScore').textContent = this.gameState.scores.ai;
                
                const selectedShip = this.gameState.ships.find(s => s.id === this.selectedShipId);
                document.getElementById('selectedShip').textContent = 
                    selectedShip ? `Ship ${this.selectedShipIndex + 1} Selected` : 'No Ship Selected';
                
                if (this.gameState.gameStartTime) {
                    const elapsed = Math.floor((Date.now() - this.gameState.gameStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('gameTime').textContent = 
                        `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Render obstacles
                for (const obstacle of this.gameState.obstacles) {
                    this.ctx.save();
                    this.ctx.fillStyle = obstacle.type === 'island' ? '#8B4513' : '#E0E0E0';
                    this.ctx.beginPath();
                    this.ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.restore();
                }
                
                // Render ships
                for (const ship of this.gameState.ships) {
                    this.ctx.save();
                    this.ctx.translate(ship.x, ship.y);
                    this.ctx.rotate(ship.angle);
                    
                    // Ship body
                    this.ctx.fillStyle = ship.team === 'team1' ? '#4169E1' : '#DC143C';
                    this.ctx.fillRect(-10, -5, 20, 10);
                    
                    // Ship front
                    this.ctx.beginPath();
                    this.ctx.moveTo(10, 0);
                    this.ctx.lineTo(14, -3);
                    this.ctx.lineTo(14, 3);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // Health bar
                    this.ctx.fillStyle = 'red';
                    this.ctx.fillRect(-10, -8, 20, 2);
                    this.ctx.fillStyle = 'green';
                    this.ctx.fillRect(-10, -8, (ship.health / ship.maxHealth) * 20, 2);
                    
                    this.ctx.restore();
                    
                    // Cannon direction
                    this.ctx.save();
                    this.ctx.translate(ship.x, ship.y);
                    this.ctx.rotate(ship.cannonAngle);
                    this.ctx.strokeStyle = ship.team === 'team1' ? '#4169E1' : '#DC143C';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, 0);
                    this.ctx.lineTo(30, 0);
                    this.ctx.stroke();
                    this.ctx.restore();
                    
                    // Selection indicator
                    if (ship.id === this.selectedShipId) {
                        this.ctx.strokeStyle = '#FFD700';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(ship.x, ship.y, 20, 0, 2 * Math.PI);
                        this.ctx.stroke();
                    }
                }
                
                // Render cannonballs
                for (const cannonball of this.gameState.cannonballs) {
                    this.ctx.fillStyle = '#FFA500';
                    this.ctx.beginPath();
                    this.ctx.arc(cannonball.x, cannonball.y, 3, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
            }
            
            startGameLoop() {
                let lastTime = Date.now();
                
                const gameLoop = () => {
                    const now = Date.now();
                    const deltaTime = (now - lastTime) / 1000;
                    lastTime = now;
                    
                    this.update(deltaTime);
                    this.render();
                    
                    requestAnimationFrame(gameLoop);
                };
                
                gameLoop();
            }
        }
        
        const game = new SinglePlayerGame();
    </script>
</body>
</html>