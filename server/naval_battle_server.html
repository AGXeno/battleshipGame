<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Naval Battle - Multiplayer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            overflow: auto;
        }
        
        /* Prevent scrolling when WASD keys are pressed */
        body.game-active {
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            background: #1a1a2e;
            min-height: 900px;
            padding-top: 20px;
        }
        
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #0f3460;
            cursor: crosshair;
            z-index: 1;
            outline: none;
        }
        
        #topScore {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            padding: 15px 25px;
            font-size: 28px;
            color: white;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        #headingDisplay {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: min(400px, 95vw);
            height: 200px;
            background: rgba(0, 0, 0, 0.1);
            border: 2px solid #16213e;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        
        #headingCanvas {
            background: transparent;
        }
        
        #headingInfo {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
        }
        
        #multiplayerControls {
            display: none;
        }
        
        #roomInput {
            padding: 8px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background: #333;
            color: white;
        }
        
        #connectionStatus {
            font-size: 12px;
            margin-top: 5px;
            color: #ccc;
        }
        
        #gameMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #16213e;
            border-radius: 15px;
            padding: 30px;
            color: white;
            text-align: center;
            z-index: 200;
            min-width: 300px;
        }
        
        #gameMenu.hidden {
            display: none;
        }
        
        #gameMenu h2 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #4169E1;
            font-size: 2em;
        }
        
        #gameMenu h2.countdown {
            font-size: 6em;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            margin: 0;
        }
        
        #controlsToggle {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 100;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #16213e;
            color: white;
            cursor: pointer;
        }
        
        #controlsPanel {
            position: absolute;
            left: 10px;
            bottom: 60px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #16213e;
            border-radius: 8px;
            padding: 15px;
            color: white;
            max-width: 300px;
            transition: transform 0.3s ease;
            z-index: 99;
        }
        
        #controlsPanel.hidden {
            transform: translateX(-100%);
        }
        
        .score-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
            min-width: 200px;
        }
        
        .team1-score {
            color: #4169E1;
        }
        
        .team2-score {
            color: #DC143C;
        }
        
        .game-info {
            color: #ccc;
            font-size: 28px;
        }
        
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: #16213e;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }
        
        button:hover {
            background: #1e3a5f;
        }
        
        .ship-controls {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .ship-controls label {
            min-width: 80px;
        }
        
        .ship-controls input[type="range"] {
            flex: 1;
            margin: 0 10px;
        }
        
        .ship-controls span {
            min-width: 80px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Background Music Audio Element -->
        <audio id="backgroundMusic" loop>
            <source src="Assets/Audio/background_audio.wav" type="audio/wav">
            Your browser does not support the audio element.
        </audio>
        
        <!-- Cannon Fire Sound Elements -->
        <audio id="cannonSound1" preload="auto">
            <source src="Assets/Audio/ship-fire/fire-1.wav" type="audio/wav">
        </audio>
        <audio id="cannonSound2" preload="auto">
            <source src="Assets/Audio/ship-fire/fire-2.wav" type="audio/wav">
        </audio>
        <audio id="cannonSound3" preload="auto">
            <source src="Assets/Audio/ship-fire/fire-3.wav" type="audio/wav">
        </audio>
        <audio id="cannonSound5" preload="auto">
            <source src="Assets/Audio/ship-fire/fire-5.wav" type="audio/wav">
        </audio>
        
        <div id="topScore">
            <div class="score-item team1-score">
                Blue Team: <span id="team1Score">0</span>
            </div>
            <div class="score-item game-info">
                Time: <span id="gameTime">0:00</span>
            </div>
            <div class="score-item team2-score">
                Red Team: <span id="team2Score">0</span>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="1000" height="700" tabindex="0"></canvas>
        
        <div id="headingDisplay">
            <canvas id="headingCanvas" width="350" height="160"></canvas>
            <div id="headingInfo">
                <div id="selectedObject">No selection</div>
                <div id="currentHeading">Tiller: --</div>
            </div>
        </div>
        
        <div id="multiplayerControls">
            <div><strong>üåê Multiplayer</strong></div>
            <input type="text" id="roomInput" placeholder="Enter Room ID" value="room1">
            <br>
            <button id="joinRoomBtn">Join Room</button>
            <button id="leaveRoomBtn" style="display: none;">Leave Room</button>
            <button id="startBtn" style="display: none;">Start Game</button>
            <div id="connectionStatus">Not connected</div>
        </div>
        
        <div id="gameMenu" class="hidden">
            <h2 id="menuTitle">Naval Battle</h2>
            <div id="menuContent">
                <p>Waiting for game to start...</p>
            </div>
        </div>
        
        <button id="controlsToggle">Controls</button>
        
        <div id="controlsPanel" class="hidden">
            <div><strong>Multiplayer Controls:</strong></div>
            <div>‚Ä¢ <strong>Left-click:</strong> Select your ships</div>
            <div>‚Ä¢ <strong>Right-click:</strong> Set cannon aim</div>
            <div>‚Ä¢ <strong>A/D keys:</strong> Steer left/right</div>
            <div>‚Ä¢ <strong>W/S keys:</strong> Speed up/down</div>
            <div>‚Ä¢ <strong>1-5 keys:</strong> Select ships by number</div>
            <div>‚Ä¢ <strong>Q/E keys:</strong> Cycle through ships</div>
            <div>‚Ä¢ <strong>P/Esc keys:</strong> Pause game</div>
            <div>‚Ä¢ Red lines show cannon directions</div>
            <div>‚Ä¢ Yellow line shows aim preview</div>
            <div>‚Ä¢ Ships auto-fire every 5 seconds</div>
            
            <div class="ship-controls">
                <label>Heading: </label>
                <input type="range" id="headingSlider" min="-45" max="45" value="0">
                <span id="headingValue">0¬∞</span>
            </div>
            
            <div class="ship-controls">
                <label>Speed: </label>
                <input type="range" id="speedSlider" min="0" max="25" value="25">
                <span id="speedValue">25</span>
            </div>
            
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #333;">
                <div style="font-weight: bold; margin-bottom: 8px;">Sound Controls:</div>
                
                <div class="ship-controls">
                    <label>Music: </label>
                    <button id="musicToggle" style="padding: 2px 8px; font-size: 11px; margin: 0 5px;">On</button>
                </div>
                
                <div class="ship-controls">
                    <label>Music Vol: </label>
                    <input type="range" id="musicVolumeSlider" min="0" max="100" value="50" style="width: 80px;" />
                    <span id="musicVolumeValue">50%</span>
                </div>
                
                <div class="ship-controls">
                    <label>Sound Effects: </label>
                    <button id="soundToggle" style="padding: 2px 8px; font-size: 11px; margin: 0 5px;">On</button>
                </div>
                
                <div class="ship-controls">
                    <label>Sound Vol: </label>
                    <input type="range" id="soundVolumeSlider" min="0" max="100" value="70" style="width: 80px;" />
                    <span id="soundVolumeValue">70%</span>
                </div>
            </div>
            
            <div style="font-size: 11px; color: #aaa; margin-top: 8px;">
                Blue team spawns bottom-left<br>
                Red team spawns top-right<br>
                Icebergs drift with ocean currents
            </div>
            
            <button onclick="document.getElementById('controlsPanel').classList.add('hidden')" 
                    style="margin-top: 10px; padding: 5px 10px; font-size: 12px;">
                Hide Controls
            </button>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Game Constants
        const GAME_CONFIG = {
            // Ship Properties
            SHIP_DEFAULT_SPEED: 25,
            SHIP_MAX_HEALTH: 3,
            SHIP_RADIUS: 20,
            SHIP_CANNON_COOLDOWN: 5000,
            SHIP_RAM_COOLDOWN: 1000,
            SHIP_SPEED_CHANGE_RATE: 15,
            SHIP_BASE_TURN_RATE: 0.8,
            SHIP_SPAWN_DELAY: 5000,
            
            // Cannonball Properties
            CANNONBALL_SPEED: 80,
            CANNONBALL_RADIUS: 3,
            CANNONBALL_RANGE: 1000,
            
            // UI and Rendering
            CANVAS_WIDTH: 1000,
            CANVAS_HEIGHT: 700,
            HEADING_COMPASS_RADIUS: 120,
            HEALTH_BAR_WIDTH: 24,
            HEALTH_BAR_HEIGHT: 5,
            
            // Physics and Movement
            DELTA_TIME_MULTIPLIER: 0.001,
            
            // Audio
            AUDIO_DEFAULT_MUSIC_VOLUME: 0.5,
            AUDIO_DEFAULT_SOUND_VOLUME: 0.7,
            
            // Obstacles
            OBSTACLE_MIN_RADIUS: 20,
            OBSTACLE_MAX_RADIUS: 35,
            OBSTACLE_DAMAGE_RADIUS: 12,
            OBSTACLE_DAMAGE_AMOUNT: 0.1,
            OBSTACLE_PUSH_FORCE: 15,
            OBSTACLE_DESTRUCTIBLE_HEALTH: 10,
            OBSTACLE_LARGE_MIN_RADIUS: 30,
            OBSTACLE_LARGE_MAX_RADIUS: 50,
            
            // Performance Optimization
            SPATIAL_GRID_SIZE: 100,
            CANNONBALL_POOL_SIZE: 50,
            TARGET_FPS: 60
        };

        class NavalBattleMultiplayer {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.headingCanvas = document.getElementById('headingCanvas');
                this.headingCtx = this.headingCanvas.getContext('2d');
                
                // Calculate scaling factor for fullscreen support
                const scaleX = window.innerWidth / 1000;
                const scaleY = window.innerHeight / 700;
                this.SCALE_AVG = (scaleX + scaleY) / 2;
                
                // Audio elements
                this.backgroundMusic = document.getElementById('backgroundMusic');
                this.cannonSound1 = document.getElementById('cannonSound1');
                this.cannonSound2 = document.getElementById('cannonSound2');
                this.cannonSound3 = document.getElementById('cannonSound3');
                this.cannonSound5 = document.getElementById('cannonSound5');
                
                this.socket = null;
                // Initialize gameState with audio properties to prevent null errors
                this.gameState = {
                    audio: {
                        musicEnabled: true,
                        musicVolume: 0.5,
                        musicStarted: false,
                        soundEnabled: true,
                        soundVolume: 0.7,
                        cannonSounds: []
                    }
                };
                this.selectedShipId = null;
                this.roomId = null;
                this.myPlayerId = null;
                this.myTeam = null;
                
                this.lastTime = 0;
                this.keys = {};
                this.mouseAimAngle = 0;
                this.selectedShipIndex = 0;
                this.lastQPressed = false;
                this.lastEPressed = false;
                this.pendingRoomJoin = null;
                this.lastCannonUpdate = 0;
                this.animationFrame = 0; // Current animation frame (0-3)
                this.lastAnimationUpdate = 0; // Last time animation frame was updated
                
                this.init();
            }

            // Image loading and management methods
            loadImages() {
                this.islandImages = [];
                this.icebergImages = [];
                this.shipImages = {
                    red: {},
                    blue: {},
                    white: {}
                };
                
                          // Load island images (6 total: 0-5)
          for (let i = 0; i < 6; i++) {
            const img = new Image();
            img.src = `Assets/Visuals/Islands/Island ${i}.png`;
            this.islandImages.push(img);
          }
          
          // Load iceberg images (12 total: 0-11)
          for (let i = 0; i < 12; i++) {
            const img = new Image();
            img.src = `Assets/Visuals/Icebergs/Iceberg ${i}.png`;
            this.icebergImages.push(img);
          }
                
                          // Load ship images for each color and direction (4 animation frames each)
          const shipColors = ['Red', 'Blue', 'White'];
          const shipDirections = ['East', 'NorthEast', 'North', 'NorthWest', 'West', 'SouthWest', 'South', 'SouthEast'];
          
          shipColors.forEach(color => {
            shipDirections.forEach(direction => {
              if (!this.shipImages[color.toLowerCase()]) {
                this.shipImages[color.toLowerCase()] = {};
              }
              if (!this.shipImages[color.toLowerCase()][direction]) {
                this.shipImages[color.toLowerCase()][direction] = [];
              }
              
              // Load all 4 animation frames (0, 1, 2, 3)
              for (let frame = 0; frame < 4; frame++) {
                const img = new Image();
                img.src = `Assets/Visuals/${color}Ship/${color}_Ship_${direction}/${color}_Ship_${direction}_${frame}.png`;
                this.shipImages[color.toLowerCase()][direction].push(img);
              }
            });
          });
            }

                getIslandImage(index) {
                    return this.islandImages[index] || this.islandImages[0];
                }

                getIcebergImage(index) {
                    return this.icebergImages[index] || this.icebergImages[0];
                }

                generateObstacles() {
                    if (!this.gameState.obstacles) {
                        this.gameState.obstacles = [];
                    }
                    
                    // Generate varied islands (static) - avoid spawning near team bases
                    const numIslands = 3 + Math.floor(Math.random() * 3); // 3-5 islands
                    const blueBase = { x: this.canvas.width * 0.1, y: this.canvas.height * 0.85 };
                    const redBase = { x: this.canvas.width * 0.9, y: this.canvas.height * 0.15 };
                    const minBaseDistance = Math.min(this.canvas.width, this.canvas.height) * 0.2; // 20% of smaller dimension
                    
                    for (let i = 0; i < numIslands; i++) {
                        let x, y, attempts = 0;
                        
                        do {
                            x = this.canvas.width * 0.1 + Math.random() * this.canvas.width * 0.8; // 10-90% of width
                            y = this.canvas.height * 0.1 + Math.random() * this.canvas.height * 0.8; // 10-90% of height
                            attempts++;
                            
                            // Check distance from both bases
                            const distToBlue = Math.sqrt((x - blueBase.x) ** 2 + (y - blueBase.y) ** 2);
                            const distToRed = Math.sqrt((x - redBase.x) ** 2 + (y - redBase.y) ** 2);
                            
                            // Check distance from existing islands
                            let tooClose = false;
                            for (const existingIsland of this.gameState.obstacles) {
                                if (existingIsland.type === 'island') {
                                    const dist = Math.sqrt((x - existingIsland.x) ** 2 + (y - existingIsland.y) ** 2);
                                    if (dist < existingIsland.radius + 200) { // Minimum spacing
                                        tooClose = true;
                                        break;
                                    }
                                }
                            }
                            
                            if (distToBlue >= minBaseDistance && distToRed >= minBaseDistance && !tooClose) {
                                break; // Good position found
                            }
                        } while (attempts < 30);
                        
                        // Create varied island sizes (smaller)
                        let radius, islandType;
                        const sizeRoll = Math.random();
                        if (sizeRoll < 0.3) {
                            // Small islands (30%)
                            radius = 30 + Math.random() * 20; // 30-50 radius
                            islandType = 'small';
                        } else if (sizeRoll < 0.7) {
                            // Medium islands (40%)
                            radius = 50 + Math.random() * 25; // 50-75 radius
                            islandType = 'medium';
                        } else {
                            // Large islands (30%)
                            radius = 75 + Math.random() * 35; // 75-110 radius
                            islandType = 'large';
                        }
                        
                        this.gameState.obstacles.push({
                            type: 'island',
                            x: x,
                            y: y,
                            radius: Math.round(radius),
                            destructible: false,
                            imageIndex: Math.floor(Math.random() * 6), // 0-5 for 6 island images
                            islandType: islandType
                        });
                        
                        console.log(`Generated ${islandType} island with radius ${Math.round(radius)} at (${Math.round(x)}, ${Math.round(y)})`);
                    }
                    
                    // Generate initial icebergs with drift properties - randomized count
                    const numIcebergs = 2 + Math.floor(Math.random() * 4); // 2-5 icebergs
                    console.log(`Generating ${numIcebergs} icebergs`);
                    
                    for (let i = 0; i < numIcebergs; i++) {
                        this.createDriftingIceberg(i < Math.ceil(numIcebergs * 0.6)); // 60% spawn on screen
                    }
                }

                createDriftingIceberg(forceOnScreen = false) {
                    let x, y;

                    if (forceOnScreen) {
                        // Force spawn on-screen in a safe location
                        let attempts = 0;
                        let validPosition = false;

                        while (!validPosition && attempts < 10) {
                            x = 150 + Math.random() * 700;
                            y = 100 + Math.random() * 500;

                            // Check distance from islands
                            let tooCloseToIsland = false;
                            if (this.gameState.obstacles) {
                                for (let obstacle of this.gameState.obstacles) {
                                    if (obstacle.type === "island") {
                                        const distToIsland = Math.sqrt(
                                            (x - obstacle.x) ** 2 + (y - obstacle.y) ** 2
                                        );
                                        if (distToIsland < obstacle.radius + 50) {
                                            tooCloseToIsland = true;
                                            break;
                                        }
                                    }
                                }
                            }

                            if (!tooCloseToIsland) {
                                validPosition = true;
                            }
                            attempts++;
                        }

                        if (!validPosition) {
                            // Fall back to off-screen spawn if we can't find a good on-screen spot
                            forceOnScreen = false;
                        }
                    }

                    if (!forceOnScreen) {
                        // Random spawn position (can be off-screen)
                        const spawnSide = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left

                        switch (spawnSide) {
                            case 0: // Top
                                x = Math.random() * this.canvas.width;
                                y = -50;
                                break;
                            case 1: // Right
                                x = this.canvas.width + 50;
                                y = Math.random() * this.canvas.height;
                                break;
                            case 2: // Bottom
                                x = Math.random() * this.canvas.width;
                                y = this.canvas.height + 50;
                                break;
                            case 3: // Left
                                x = -50;
                                y = Math.random() * this.canvas.height;
                                break;
                        }
                    }

                    const iceberg = {
                        type: "iceberg",
                        x: x,
                        y: y,
                        radius: 20 + Math.random() * 15,
                        destructible: true,
                        imageIndex: Math.floor(Math.random() * 12), // 0-11 for 12 iceberg images
                        // Drift properties - moderate speed
                        driftAngle: Math.random() * Math.PI * 2, // Random direction
                        driftSpeed: 3.5 + Math.random() * 4, // Moderate speed (3.5-7.5 pixels per second)
                        lastPositionUpdate: Date.now(),
                    };

                    if (!this.gameState.obstacles) {
                        this.gameState.obstacles = [];
                    }
                    this.gameState.obstacles.push(iceberg);
                }

                updateIcebergDrift(deltaTime) {
                    if (!this.gameState.obstacles) return;
                    
                    const currentTime = Date.now();

                    // Update existing iceberg positions
                    for (let i = this.gameState.obstacles.length - 1; i >= 0; i--) {
                        const obstacle = this.gameState.obstacles[i];

                        if (obstacle.type === "iceberg") {
                            // Calculate drift movement
                            const driftX =
                                Math.cos(obstacle.driftAngle) *
                                obstacle.driftSpeed *
                                deltaTime *
                                0.001;
                            const driftY =
                                Math.sin(obstacle.driftAngle) *
                                obstacle.driftSpeed *
                                deltaTime *
                                0.001;

                            const newX = obstacle.x + driftX;
                            const newY = obstacle.y + driftY;

                            // Update position
                            obstacle.x = newX;
                            obstacle.y = newY;
                            obstacle.lastPositionUpdate = currentTime;

                            // Wrap around screen edges with buffer zone
                            const buffer = 100;
                            if (obstacle.x < -buffer) {
                                obstacle.x = this.canvas.width + buffer;
                            } else if (obstacle.x > this.canvas.width + buffer) {
                                obstacle.x = -buffer;
                            }
                            if (obstacle.y < -buffer) {
                                obstacle.y = this.canvas.height + buffer;
                            } else if (obstacle.y > this.canvas.height + buffer) {
                                obstacle.y = -buffer;
                            }
                        }
                    }

                    // Remove dead obstacles
                    this.gameState.obstacles = this.gameState.obstacles.filter(
                        (o) => !o.dead
                    );
                }
                
                getShipImage(team, angle) {
                    // Convert angle to degrees and normalize to 0-360
                    let degrees = (angle * 180 / Math.PI) % 360;
                    if (degrees < 0) degrees += 360;
                    
                    // Corrected direction mapping
                    let direction;
                    if (degrees >= 337.5 || degrees < 22.5) {
                        direction = 'East';
                    } else if (degrees >= 22.5 && degrees < 67.5) {
                        direction = 'SouthEast';
                    } else if (degrees >= 67.5 && degrees < 112.5) {
                        direction = 'South';
                    } else if (degrees >= 112.5 && degrees < 157.5) {
                        direction = 'SouthWest';
                    } else if (degrees >= 157.5 && degrees < 202.5) {
                        direction = 'West';
                    } else if (degrees >= 202.5 && degrees < 247.5) {
                        direction = 'NorthWest';
                    } else if (degrees >= 247.5 && degrees < 292.5) {
                        direction = 'North';
                    } else if (degrees >= 292.5 && degrees < 337.5) {
                        direction = 'NorthEast';
                    }
                    
                    // Determine ship color based on team
                    let color;
                    if (team === 'team1') {
                        color = 'blue';
                    } else if (team === 'team2') {
                        color = 'red';
                    } else {
                        color = 'white'; // Treat all other cases as neutral
                    }
                    
                    // Return the current animation frame
                    const shipImageArray = this.shipImages[color]?.[direction];
                    if (shipImageArray && shipImageArray.length > 0) {
                        return shipImageArray[this.animationFrame] || shipImageArray[0];
                    }
                    return null;
                }
            
            resizeCanvas() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                this.canvas.width = width;
                this.canvas.height = height;
                const scaleX = width / 1000;
                const scaleY = height / 700;
                this.SCALE_AVG = (scaleX + scaleY) / 2;
            }
            
            init() {
                this.loadImages();
                this.setupCanvas();
                this.setupControls();
                this.setupInitialMenu();
                this.setupSocket();
                this.gameLoop();
                this.checkUrlParams();
            }
            
            setupInitialMenu() {
                console.log('Setting up initial menu...');
                // Show initial room joining menu
                document.getElementById('menuTitle').textContent = 'Join Multiplayer Room';
                document.getElementById('menuContent').innerHTML = `
                    <div style="text-align: center;">
                        <p>Enter a room ID to join or create a room</p>
                        <input type="text" id="roomInput" placeholder="Enter room ID" value="room1" style="padding: 8px; margin: 10px; border: none; border-radius: 4px; background: #333; color: white;">
                        <br>
                        <button id="joinRoomBtn" disabled>Connecting...</button>
                        <br><br>
                        <button id="backToMainBtn" style="background: #666; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">Back to Main Menu</button>
                        <div id="connectionStatus">Connecting to server...</div>
                    </div>
                `;
                
                // Add event listener for join room button
                const joinRoomBtn = document.getElementById('joinRoomBtn');
                if (joinRoomBtn) {
                    joinRoomBtn.addEventListener('click', (e) => {
                        console.log('üñ±Ô∏è Join Room button clicked!');
                        console.log('Event:', e);
                        console.log('Button disabled:', joinRoomBtn.disabled);
                        console.log('Button text:', joinRoomBtn.textContent);
                        e.preventDefault();
                        this.joinRoom();
                    });
                    console.log('üìù Event listener added to Join Room button');
                } else {
                    console.error('‚ùå Could not find joinRoomBtn to add event listener');
                }
                
                // Add event listener for back to main menu button
                const backToMainBtn = document.getElementById('backToMainBtn');
                if (backToMainBtn) {
                    backToMainBtn.addEventListener('click', () => {
                        window.location.href = 'index.html';
                    });
                    console.log('üìù Event listener added to Back to Main Menu button');
                } else {
                    console.error('‚ùå Could not find backToMainBtn to add event listener');
                }
                
                document.getElementById('gameMenu').classList.remove('hidden');
                console.log('Initial menu setup complete');
                
                // Add global click listener for debugging AND event delegation
                document.addEventListener('click', (e) => {
                    console.log('üåê Global click detected:', e.target);
                    console.log('Target id:', e.target.id);
                    console.log('Target class:', e.target.className);
                    console.log('Target text:', e.target.textContent);
                    
                    // Handle start game button via event delegation
                    if (e.target.id === 'startBtn') {
                        console.log('üéØ Start Game button clicked via delegation!');
                        e.preventDefault();
                        // Use proper server start game instead of simple mode
                        this.startGame();
                    }
                });
            }
            
            setupCanvas() {
                // Set canvas to full window size
                this.resizeCanvas();
                
                // Listen for window resize
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    this.handleCanvasRightClick(e);
                });
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('wheel', (e) => this.handleMouseWheel(e));
                
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    
                    // Prevent browser default behavior for game keys
                    if (['KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyQ', 'KeyE', 'KeyP', 'Escape'].includes(e.code) ||
                        (e.code >= 'Digit1' && e.code <= 'Digit5')) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    
                    // Handle pause/escape
                    if (e.code === 'KeyP' || e.code === 'Escape') {
                        this.togglePause();
                    }
                    
                    // Handle number key selection (1-5)
                    if (e.code >= 'Digit1' && e.code <= 'Digit5') {
                        const shipNumber = parseInt(e.code.slice(-1)) - 1;
                        this.selectShipByNumber(shipNumber);
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
            }
            
            setupControls() {
                const headingSlider = document.getElementById('headingSlider');
                const headingValue = document.getElementById('headingValue');
                const speedSlider = document.getElementById('speedSlider');
                const speedValue = document.getElementById('speedValue');
                
                headingSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    headingValue.textContent = value + '¬∞';
                    
                    if (this.selectedShipId && this.socket) {
                        this.socket.emit('ship-control', {
                            shipId: this.selectedShipId,
                            action: 'rudder',
                            value: value * Math.PI/180
                        });
                    }
                });

                speedSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    speedValue.textContent = value;
                    
                    if (this.selectedShipId && this.socket) {
                        this.socket.emit('ship-control', {
                            shipId: this.selectedShipId,
                            action: 'speed',
                            value: value
                        });
                    }
                });
                
                document.getElementById('controlsToggle').addEventListener('click', () => {
                    const panel = document.getElementById('controlsPanel');
                    panel.classList.toggle('hidden');
                });
                
                // Setup audio controls
                this.setupAudioControls();
                this.setupCannonSounds();
            }
            
            setupAudioControls() {
                const musicToggle = document.getElementById('musicToggle');
                const musicVolumeSlider = document.getElementById('musicVolumeSlider');
                const musicVolumeValue = document.getElementById('musicVolumeValue');
                const soundToggle = document.getElementById('soundToggle');
                const soundVolumeSlider = document.getElementById('soundVolumeSlider');
                const soundVolumeValue = document.getElementById('soundVolumeValue');

                // Initialize controls with current state
                if (musicToggle) {
                    musicToggle.textContent = this.gameState.audio.musicEnabled ? 'On' : 'Off';
                    musicVolumeSlider.value = this.gameState.audio.musicVolume * 100;
                    musicVolumeValue.textContent = Math.round(this.gameState.audio.musicVolume * 100) + '%';
                }
                
                if (soundToggle) {
                    soundToggle.textContent = this.gameState.audio.soundEnabled ? 'On' : 'Off';
                    soundVolumeSlider.value = this.gameState.audio.soundVolume * 100;
                    soundVolumeValue.textContent = Math.round(this.gameState.audio.soundVolume * 100) + '%';
                }

                // Music toggle
                if (musicToggle) {
                    musicToggle.addEventListener('click', () => {
                        this.gameState.audio.musicEnabled = !this.gameState.audio.musicEnabled;
                        musicToggle.textContent = this.gameState.audio.musicEnabled ? 'On' : 'Off';
                        
                        if (this.gameState.audio.musicEnabled) {
                            if (this.gameState.gameStarted) {
                                this.playBackgroundMusic();
                            }
                        } else {
                            this.pauseBackgroundMusic();
                        }
                    });
                }

                // Music volume slider
                if (musicVolumeSlider) {
                    musicVolumeSlider.addEventListener('input', (e) => {
                        const volume = parseInt(e.target.value) / 100;
                        this.gameState.audio.musicVolume = volume;
                        musicVolumeValue.textContent = e.target.value + '%';
                        
                        if (this.backgroundMusic) {
                            this.backgroundMusic.volume = volume;
                        }
                    });
                }

                // Sound effects toggle
                if (soundToggle) {
                    soundToggle.addEventListener('click', () => {
                        this.gameState.audio.soundEnabled = !this.gameState.audio.soundEnabled;
                        soundToggle.textContent = this.gameState.audio.soundEnabled ? 'On' : 'Off';
                    });
                }

                // Sound effects volume slider
                if (soundVolumeSlider) {
                    soundVolumeSlider.addEventListener('input', (e) => {
                        const volume = parseInt(e.target.value) / 100;
                        this.gameState.audio.soundVolume = volume;
                        soundVolumeValue.textContent = e.target.value + '%';
                        this.updateCannonSoundVolumes();
                    });
                }
            }

            playBackgroundMusic() {
                if (this.backgroundMusic && this.gameState.audio.musicEnabled) {
                    this.backgroundMusic.volume = this.gameState.audio.musicVolume;
                    this.backgroundMusic.play().then(() => {
                        console.log('Background music started successfully');
                        this.gameState.audio.musicStarted = true;
                    }).catch(error => {
                        console.log("Audio play failed:", error);
                        // Retry once after user interaction
                        if (!this.gameState.audio.musicStarted) {
                            console.log('Retrying audio playback...');
                            setTimeout(() => {
                                this.backgroundMusic.play().catch(e => {
                                    console.log('Audio retry also failed:', e);
                                });
                            }, 1000);
                        }
                    });
                }
            }

            pauseBackgroundMusic() {
                if (this.backgroundMusic) {
                    this.backgroundMusic.pause();
                }
            }

            setupCannonSounds() {
                // Store cannon sound elements in the game state
                this.gameState.audio.cannonSounds = [
                    this.cannonSound1,
                    this.cannonSound2,
                    this.cannonSound3,
                    this.cannonSound5
                ];
                
                // Set initial volume for all cannon sounds
                this.updateCannonSoundVolumes();
            }

            updateCannonSoundVolumes() {
                const volume = this.gameState.audio.soundVolume;
                for (let sound of this.gameState.audio.cannonSounds) {
                    if (sound) {
                        sound.volume = volume;
                    }
                }
            }

            playRandomCannonSound() {
                if (!this.gameState.audio.soundEnabled || this.gameState.audio.cannonSounds.length === 0) {
                    return;
                }

                // Pick a random cannon sound
                const randomIndex = Math.floor(Math.random() * this.gameState.audio.cannonSounds.length);
                const sound = this.gameState.audio.cannonSounds[randomIndex];
                
                if (sound) {
                    // Reset the sound to the beginning and play
                    sound.currentTime = 0;
                    sound.play().catch(error => {
                        console.log("Cannon sound play failed:", error);
                    });
                }
            }
            
            setupSocket() {
                console.log('Setting up socket connection...');
                this.socket = io();
                
                this.socket.on('connect', () => {
                    console.log('‚úÖ Connected to server successfully');
                    
                    // Force update the UI elements
                    setTimeout(() => {
                        const connectionStatus = document.getElementById('connectionStatus');
                        const joinBtn = document.getElementById('joinRoomBtn');
                        
                        console.log('üîç Updating UI elements...');
                        console.log('connectionStatus element:', !!connectionStatus);
                        console.log('joinBtn element:', !!joinBtn);
                        
                        if (connectionStatus) {
                            connectionStatus.textContent = 'Connected to server';
                            console.log('‚úÖ Updated connection status');
                        }
                        
                        if (joinBtn) {
                            // Force a complete UI rebuild instead of just updating properties
                            console.log('üîÑ Rebuilding entire menu with connected state');
                            document.getElementById('menuContent').innerHTML = `
                                <div style="text-align: center;">
                                    <p>Enter a room ID to join or create a room</p>
                                    <input type="text" id="roomInput" placeholder="Enter room ID" value="room1" style="padding: 8px; margin: 10px; border: none; border-radius: 4px; background: #333; color: white;">
                                    <br>
                                    <button id="joinRoomBtn" style="padding: 10px 20px; margin: 5px; border: none; border-radius: 5px; background: #16213e; color: white; cursor: pointer; font-size: 16px;">Join Room</button>
                                    <div id="connectionStatus">Connected to server</div>
                                </div>
                            `;
                            
                            // Re-add event listener to the new button
                            const newJoinBtn = document.getElementById('joinRoomBtn');
                            if (newJoinBtn) {
                                newJoinBtn.addEventListener('click', (e) => {
                                    console.log('üñ±Ô∏è New Join Room button clicked!');
                                    e.preventDefault();
                                    this.joinRoom();
                                });
                                console.log('‚úÖ New Join Room button created and enabled');
                            }
                        } else {
                            console.error('‚ùå Join Room button not found');
                        }
                        
                        // Try auto-join from URL params now that socket is connected
                        this.tryAutoJoin();
                    }, 100);
                });
                
                this.socket.on('joined-room', (data) => {
                    console.log('‚úÖ Received joined-room event:', data);
                    this.roomId = data.roomId;
                    this.myPlayerId = data.playerId;
                    this.isHost = data.isHost;
                    
                    // Assign teams based on join order for signaling server compatibility
                    this.myTeam = data.isHost ? 'team1' : 'team2';
                    
                    document.getElementById('connectionStatus').textContent = 
                        `In room ${data.roomId} - You are ${this.myTeam === 'team1' ? 'Blue Team (Host)' : 'Red Team'}`;
                    
                    // Make sure menu is visible
                    document.getElementById('gameMenu').classList.remove('hidden');
                    
                    // Show simplified ready state for signaling server
                    // Add small delay to ensure DOM is ready
                    setTimeout(() => {
                        this.showSimpleRoomStatus(data.playerCount, data.isHost);
                    }, 100);
                });
                
                this.socket.on('game-state', (gameState) => {
                    // Preserve audio settings when receiving game state from server
                    const audioSettings = this.gameState.audio;
                    
                    // Track previous cannonballs to detect new ones
                    const previousCannonballs = this.gameState.cannonballs ? 
                        new Set(this.gameState.cannonballs.map(c => c.id)) : new Set();
                    
                    this.gameState = gameState;
                    // Restore audio settings if not provided by server
                    if (!this.gameState.audio) {
                        this.gameState.audio = audioSettings;
                    }
                    
                    // Check for new cannonballs and play sound
                    if (this.gameState.cannonballs) {
                        for (const cannonball of this.gameState.cannonballs) {
                            if (!previousCannonballs.has(cannonball.id)) {
                                // New cannonball detected, play sound
                                this.playRandomCannonSound();
                                break; // Only play one sound per update
                            }
                        }
                    }
                    
                    this.updateSelectedShipDisplay();
                });
                
                // Note: cannon sounds are now played when detecting new cannonballs in game-state
                
                this.socket.on('game-started', (data) => {
                    console.log('üéÆ Game started event received:', data);
                    document.getElementById('startBtn').style.display = 'none';
                    document.getElementById('gameMenu').classList.add('hidden');
                    console.log('‚úÖ Game menu hidden, gameplay should begin');
                    
                    // Generate obstacles when game starts
                    this.generateObstacles();
                    
                    // Start background music when game starts
                    // Add a small delay to ensure audio context is ready
                    setTimeout(() => {
                        this.playBackgroundMusic();
                    }, 100);
                    
                    // Prevent browser scrolling and focus canvas for keyboard input
                    document.body.classList.add('game-active');
                    this.canvas.focus();
                    console.log('‚úÖ Canvas focused for keyboard input');
                    
                    // Auto-select first ship when game starts
                    setTimeout(() => {
                        this.autoSelectFirstShip();
                    }, 1000);
                });
                
                this.socket.on('player-joined', (data) => {
                    console.log('Player joined:', data.playerId);
                    this.showSimpleRoomStatus(data.playerCount, this.isHost);
                });
                
                this.socket.on('player-left', (data) => {
                    console.log('Player left:', data.playerId);
                    this.showSimpleRoomStatus(data.playerCount, this.isHost);
                });
                
                this.socket.on('players-ready', (data) => {
                    this.updatePlayerStatus(data.playerCount, data.playersReady);
                });
                
                this.socket.on('player-ready-status', (data) => {
                    this.playerReady = data.isReady;
                    this.updatePlayerStatus(data.playerCount, data.allPlayersReady);
                });
                
                this.socket.on('waiting-for-players', (data) => {
                    document.getElementById('menuTitle').textContent = 'Waiting for Players';
                    document.getElementById('menuContent').innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <p>Players in room: ${data.playerCount}/2</p>
                            <p>Waiting for all players to be ready...</p>
                            <div style="margin: 20px 0;">
                                <div style="display: inline-block; width: 20px; height: 20px; border: 2px solid #fff; border-radius: 50%; border-top-color: transparent; animation: spin 1s linear infinite;"></div>
                            </div>
                        </div>
                        <style>
                            @keyframes spin { to { transform: rotate(360deg); } }
                        </style>
                    `;
                    document.getElementById('gameMenu').classList.remove('hidden');
                });
                
                this.socket.on('disconnect', () => {
                    console.log('‚ùå Disconnected from server');
                    document.getElementById('connectionStatus').textContent = 'Disconnected from server';
                });
                
                this.socket.on('connect_error', (error) => {
                    console.error('‚ùå Connection error:', error);
                    document.getElementById('connectionStatus').textContent = 'Connection failed';
                });
            }
            
            checkUrlParams() {
                console.log('üîç Checking URL params...');
                console.log('Current URL:', window.location.href);
                console.log('Search string:', window.location.search);
                
                const urlParams = new URLSearchParams(window.location.search);
                const room = urlParams.get('room');
                const isHost = urlParams.get('host') === 'true';
                
                console.log('Parsed room:', room);
                console.log('Parsed isHost:', isHost);
                
                if (room) {
                    console.log('üìã Found room in URL params:', room, 'isHost:', isHost);
                    // Store for later auto-join when socket connects
                    this.pendingRoomJoin = room;
                    
                    // Set the room input value
                    setTimeout(() => {
                        const roomInput = document.getElementById('roomInput');
                        if (roomInput) {
                            roomInput.value = room;
                            console.log('üìù Set room input value to:', room);
                        }
                    }, 50);
                } else {
                    console.log('‚ùå No room found in URL params');
                }
            }
            
            tryAutoJoin() {
                console.log('üîç tryAutoJoin called');
                console.log('pendingRoomJoin:', this.pendingRoomJoin);
                console.log('socket connected:', this.socket?.connected);
                
                if (this.pendingRoomJoin && this.socket?.connected) {
                    console.log('üöÄ Auto-joining room:', this.pendingRoomJoin);
                    this.joinRoom();
                    this.pendingRoomJoin = null; // Clear after joining
                } else {
                    console.log('‚ùå Auto-join conditions not met');
                }
            }
            
            showSimpleRoomStatus(playerCount, isHost) {
                const menuContent = document.getElementById('menuContent');
                
                if (menuContent && this.roomId) {
                    const title = `Room: ${this.roomId}`;
                    document.getElementById('menuTitle').textContent = title;
                    
                    if (isHost) {
                        // Host view - simplified for signaling server
                        menuContent.innerHTML = `
                            <div style="text-align: center;">
                                <p>You are <strong>Host</strong> on the <strong>${this.myTeam === 'team1' ? 'Blue Team' : 'Red Team'}</strong></p>
                                <div style="padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px; margin: 10px 0;">
                                    <p>Players in room: ${playerCount}/2</p>
                                    ${playerCount === 2 ? '<p style="color: #4CAF50;">‚úì Both players connected!</p>' : '<p style="color: #FFA500;">Waiting for second player...</p>'}
                                </div>
                                <button id="startBtn" ${playerCount < 2 ? 'disabled' : ''}>Start Game</button>
                                <button id="returnToLobbyBtn">Return to Lobby</button>
                            </div>
                        `;
                    } else {
                        // Non-host view - simplified for signaling server
                        menuContent.innerHTML = `
                            <div style="text-align: center;">
                                <p>You are on the <strong>${this.myTeam === 'team1' ? 'Blue Team' : 'Red Team'}</strong></p>
                                <div style="padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px; margin: 10px 0;">
                                    <p>Players in room: ${playerCount}/2</p>
                                    <p style="color: #4CAF50;">‚úì Connected and ready!</p>
                                </div>
                                <p>Waiting for host to start the game...</p>
                                <button id="returnToLobbyBtn">Return to Lobby</button>
                            </div>
                        `;
                    }
                    
                    // Re-add event listeners
                    const startBtn = document.getElementById('startBtn');
                    const returnBtn = document.getElementById('returnToLobbyBtn');
                    
                    if (startBtn) {
                        startBtn.addEventListener('click', (e) => {
                            console.log('üéØ Start Game button event fired!');
                            console.log('Event:', e);
                            console.log('Button disabled:', startBtn.disabled);
                            e.preventDefault();
                            this.startGameSimple();
                        });
                        startBtn.style.opacity = (playerCount < 2) ? '0.5' : '1';
                        console.log('üìù Start Game event listener added');
                    } else {
                        console.error('‚ùå Start Game button not found for event listener');
                    }
                    
                    if (returnBtn) {
                        returnBtn.addEventListener('click', () => this.returnToLobby());
                    }
                }
            }
            
            updatePlayerStatus(playerCount, playersReady) {
                // Update the menu content to include player status
                const menuContent = document.getElementById('menuContent');
                if (menuContent && this.roomId) {
                    const title = `Room: ${this.roomId}`;
                    document.getElementById('menuTitle').textContent = title;
                    
                    const isReady = this.playerReady || false;
                    
                    if (this.isHost) {
                        // Host view - can start game when all ready
                        menuContent.innerHTML = `
                            <div style="text-align: center;">
                                <p>You are <strong>Host</strong> on the <strong>${this.myTeam === 'team1' ? 'Blue Team' : 'Red Team'}</strong></p>
                                <div style="padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px; margin: 10px 0;">
                                    <p>Players in room: ${playerCount}/2</p>
                                    ${playersReady && playerCount === 2 ? '<p style="color: #4CAF50;">‚úì All players ready!</p>' : '<p style="color: #FFA500;">Waiting for players to be ready...</p>'}
                                </div>
                                <button id="startBtn" ${!playersReady || playerCount < 2 ? 'disabled' : ''}>Start Game</button>
                                <button id="returnToLobbyBtn">Return to Lobby</button>
                            </div>
                        `;
                    } else {
                        // Non-host view - ready button
                        menuContent.innerHTML = `
                            <div style="text-align: center;">
                                <p>You are on the <strong>${this.myTeam === 'team1' ? 'Blue Team' : 'Red Team'}</strong></p>
                                <div style="padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px; margin: 10px 0;">
                                    <p>Players in room: ${playerCount}/2</p>
                                    <p>Status: ${isReady ? '<span style="color: #4CAF50;">Ready ‚úì</span>' : '<span style="color: #FFA500;">Not Ready</span>'}</p>
                                </div>
                                <button id="readyBtn">${isReady ? 'Not Ready' : 'Ready'}</button>
                                <button id="returnToLobbyBtn">Return to Lobby</button>
                            </div>
                        `;
                    }
                    
                    // Re-add event listeners
                    const startBtn = document.getElementById('startBtn');
                    const readyBtn = document.getElementById('readyBtn');
                    const returnBtn = document.getElementById('returnToLobbyBtn');
                    
                    if (startBtn) {
                        startBtn.addEventListener('click', () => this.startGame());
                        startBtn.style.opacity = (!playersReady || playerCount < 2) ? '0.5' : '1';
                    }
                    
                    if (readyBtn) {
                        readyBtn.addEventListener('click', () => this.toggleReady());
                    }
                    
                    if (returnBtn) {
                        returnBtn.addEventListener('click', () => this.returnToLobby());
                    }
                }
            }
            
            createPlayerStatusDiv() {
                const statusDiv = document.createElement('div');
                statusDiv.id = 'playerStatus';
                const menuContent = document.getElementById('menuContent');
                if (menuContent) {
                    menuContent.appendChild(statusDiv);
                }
                return statusDiv;
            }
            
            togglePause() {
                if (!this.gameState || !this.gameState.gameStarted) return;
                
                if (document.getElementById('gameMenu').classList.contains('hidden')) {
                    // Show pause menu
                    document.getElementById('menuTitle').textContent = 'Game Paused';
                    document.getElementById('menuContent').innerHTML = `
                        <button id="resumeBtn">Resume Game</button>
                        <button id="restartBtn">Restart Game</button>
                        <button id="mainMenuBtn">Return to Main Menu</button>
                        <button id="leaveRoomBtn">Leave Room</button>
                    `;
                    
                    // Add event listeners for pause menu buttons
                    document.getElementById('resumeBtn').addEventListener('click', () => this.togglePause());
                    document.getElementById('restartBtn').addEventListener('click', () => this.restartGame());
                    document.getElementById('mainMenuBtn').addEventListener('click', () => this.returnToMainMenu());
                    document.getElementById('leaveRoomBtn').addEventListener('click', () => this.leaveRoom());
                    
                    document.getElementById('gameMenu').classList.remove('hidden');
                } else {
                    // Hide pause menu
                    document.getElementById('gameMenu').classList.add('hidden');
                }
            }
            
            restartGame() {
                if (this.socket && this.roomId) {
                    this.socket.emit('restart-game', this.roomId);
                }
                document.getElementById('gameMenu').classList.add('hidden');
            }
            
            returnToMainMenu() {
                // Leave room and navigate back to the main game selection menu
                if (this.socket) {
                    this.socket.disconnect();
                }
                window.location.href = 'index.html';
            }
            
            returnToLobby() {
                this.leaveRoom();
                // Reset to lobby state
                document.getElementById('menuTitle').textContent = 'Join Multiplayer Room';
                document.getElementById('menuContent').innerHTML = `
                    <div style="text-align: center;">
                        <p>Enter a room ID to join or create a room</p>
                        <input type="text" id="roomInput" placeholder="Enter room ID" value="room1" style="padding: 8px; margin: 10px; border: none; border-radius: 4px; background: #333; color: white;">
                        <br>
                        <button id="joinRoomBtn">Join Room</button>
                        <br><br>
                        <button id="backToMainBtn" style="background: #666; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">Back to Main Menu</button>
                    </div>
                `;
                
                // Add event listener for join room button
                document.getElementById('joinRoomBtn').addEventListener('click', () => this.joinRoom());
                
                // Add event listener for back to main menu button
                document.getElementById('backToMainBtn').addEventListener('click', () => {
                    window.location.href = 'index.html';
                });
                
                document.getElementById('gameMenu').classList.remove('hidden');
            }
            
            joinRoom() {
                console.log('üîÑ joinRoom() called');
                const roomInput = document.getElementById('roomInput');
                const roomId = roomInput ? roomInput.value.trim() : '';
                
                console.log('Room ID:', roomId);
                console.log('Socket connected:', !!this.socket?.connected);
                
                // Initialize audio context on user interaction
                if (this.backgroundMusic) {
                    this.backgroundMusic.load();
                    console.log('Audio context initialized');
                }
                
                if (!roomId) {
                    console.error('‚ùå No room ID provided');
                    return;
                }
                
                if (!this.socket) {
                    console.error('‚ùå Socket not initialized');
                    return;
                }
                
                if (!this.socket.connected) {
                    console.error('‚ùå Socket not connected');
                    return;
                }
                
                console.log('‚úÖ Emitting join-room event with roomId:', roomId);
                this.socket.emit('join-room', roomId);
            }
            
            leaveRoom() {
                if (this.socket) {
                    this.socket.emit('leave-room');
                    this.socket.disconnect();
                    this.socket = io();
                    this.setupSocket();
                }
                
                document.getElementById('joinRoomBtn').style.display = 'inline-block';
                document.getElementById('leaveRoomBtn').style.display = 'none';
                document.getElementById('startBtn').style.display = 'none';
                document.getElementById('connectionStatus').textContent = 'Connected to server';
                this.gameState = null;
                this.selectedShipId = null;
            }
            
            startGame() {
                console.log('üéÆ startGame() called');
                console.log('Socket:', !!this.socket);
                console.log('Room ID:', this.roomId);
                console.log('Is Host:', this.isHost);
                
                // Try to start background music immediately on user click
                this.playBackgroundMusic();
                
                if (this.socket && this.roomId && this.isHost) {
                    console.log('‚úÖ Emitting start-game event to server');
                    this.socket.emit('start-game', this.roomId);
                } else {
                    console.error('‚ùå Cannot start game - missing requirements');
                }
            }
            
            startGameSimple() {
                // For signaling server compatibility - just hide menu and start
                console.log('üéÆ Starting game (simplified mode)');
                document.getElementById('gameMenu').classList.add('hidden');
                // Initialize a basic game state since signaling server doesn't provide one
                this.initializeBasicGameState();
                
                // Start background music
                this.playBackgroundMusic();
            }
            
            initializeBasicGameState() {
                // Preserve existing audio settings
                const audioSettings = this.gameState.audio;
                
                this.gameState = {
                    ships: [],
                    cannonballs: [],
                    obstacles: [],
                    scores: { team1: 0, team2: 0 },
                    gameStarted: true,
                    gameStartTime: Date.now(),
                    audio: audioSettings // Use preserved settings
                };
                console.log('üéØ Basic game state initialized');
            }
            
            toggleReady() {
                if (this.socket && this.roomId) {
                    this.socket.emit('toggle-ready', this.roomId);
                }
            }
            
            handleCanvasClick(e) {
                if (!this.gameState || !this.gameState.gameStarted) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                // Only select ships owned by this player
                const myShips = this.gameState.ships.filter(s => s.ownerId === this.myPlayerId);
                
                for (let ship of myShips) {
                    const dx = x - ship.x;
                    const dy = y - ship.y;
                    if (Math.sqrt(dx*dx + dy*dy) < 15) {
                        this.selectedShipId = ship.id;
                        this.updateSelectedShipDisplay(ship);
                        break;
                    }
                }
            }
            
            handleCanvasRightClick(e) {
                if (!this.gameState || !this.gameState.gameStarted || !this.selectedShipId) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                const ship = this.gameState.ships.find(s => s.id === this.selectedShipId);
                if (ship && ship.ownerId === this.myPlayerId) {
                    const dx = x - ship.x;
                    const dy = y - ship.y;
                    const angle = Math.atan2(dy, dx);
                    
                    if (this.socket) {
                        this.socket.emit('ship-control', {
                            shipId: this.selectedShipId,
                            action: 'cannon',
                            value: angle
                        });
                    }
                }
            }
            
            handleMouseMove(e) {
                if (!this.selectedShipId || !this.gameState) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                const ship = this.gameState.ships.find(s => s.id === this.selectedShipId);
                if (ship && ship.ownerId === this.myPlayerId) {
                    const dx = mouseX - ship.x;
                    const dy = mouseY - ship.y;
                    this.mouseAimAngle = Math.atan2(dy, dx);
                    
                    // Throttle cannon updates to avoid spamming server
                    const now = Date.now();
                    if (now - this.lastCannonUpdate > 50) { // Update every 50ms
                        this.lastCannonUpdate = now;
                        
                        if (this.socket) {
                            this.socket.emit('ship-control', {
                                shipId: this.selectedShipId,
                                action: 'cannon',
                                value: this.mouseAimAngle
                            });
                        }
                    }
                }
            }
            
            handleMouseWheel(e) {
                e.preventDefault();
                
                if (!this.gameState || !this.gameState.ships) return;
                
                const myShips = this.gameState.ships.filter(s => s.ownerId === this.myPlayerId);
                if (myShips.length === 0) return;
                
                let currentIndex = myShips.findIndex(s => s.id === this.selectedShipId);
                if (currentIndex === -1) currentIndex = 0;
                
                if (e.deltaY > 0) {
                    currentIndex = (currentIndex + 1) % myShips.length;
                } else {
                    currentIndex = (currentIndex - 1 + myShips.length) % myShips.length;
                }
                
                this.selectedShipId = myShips[currentIndex].id;
                this.updateSelectedShipDisplay(myShips[currentIndex]);
            }
            
            selectShipByNumber(shipNumber) {
                if (!this.gameState || !this.gameState.ships) return;
                
                const myShips = this.gameState.ships.filter(s => s.ownerId === this.myPlayerId);
                const targetShip = myShips.find(ship => ship.shipNumber === shipNumber + 1);
                
                if (targetShip) {
                    this.selectedShipId = targetShip.id;
                    this.updateSelectedShipDisplay(targetShip);
                }
            }
            
            autoSelectFirstShip() {
                if (!this.gameState || !this.gameState.ships) {
                    console.log('‚è≥ No ships available yet, retrying...');
                    setTimeout(() => this.autoSelectFirstShip(), 500);
                    return;
                }
                
                const myShips = this.gameState.ships.filter(s => s.ownerId === this.myPlayerId);
                if (myShips.length > 0) {
                    this.selectedShipId = myShips[0].id;
                    this.updateSelectedShipDisplay(myShips[0]);
                    console.log('‚úÖ Auto-selected first ship:', myShips[0].id);
                } else {
                    console.log('‚è≥ No player ships found, retrying...');
                    setTimeout(() => this.autoSelectFirstShip(), 500);
                }
            }
            
            updateControls() {
                if (!this.gameState || !this.gameState.gameStarted) return;
                
                const myShips = this.gameState.ships.filter(s => s.ownerId === this.myPlayerId);
                
                // Q/E for selection cycling
                if (this.keys['KeyQ'] && !this.lastQPressed) {
                    this.lastQPressed = true;
                    if (myShips.length > 0) {
                        let currentIndex = myShips.findIndex(s => s.id === this.selectedShipId);
                        currentIndex = (currentIndex + 1) % myShips.length;
                        this.selectedShipId = myShips[currentIndex].id;
                        this.updateSelectedShipDisplay(myShips[currentIndex]);
                    }
                } else if (!this.keys['KeyQ']) {
                    this.lastQPressed = false;
                }
                
                if (this.keys['KeyE'] && !this.lastEPressed) {
                    this.lastEPressed = true;
                    if (myShips.length > 0) {
                        let currentIndex = myShips.findIndex(s => s.id === this.selectedShipId);
                        currentIndex = (currentIndex - 1 + myShips.length) % myShips.length;
                        this.selectedShipId = myShips[currentIndex].id;
                        this.updateSelectedShipDisplay(myShips[currentIndex]);
                    }
                } else if (!this.keys['KeyE']) {
                    this.lastEPressed = false;
                }
                
                // Ship controls
                const ship = this.gameState.ships.find(s => s.id === this.selectedShipId);
                if (ship && ship.ownerId === this.myPlayerId && this.socket) {
                    
                    // A/D for steering
                    if (this.keys['KeyA']) {
                        this.socket.emit('ship-control', {
                            shipId: this.selectedShipId,
                            action: 'rudder-adjust',
                            value: -0.02
                        });
                    }
                    if (this.keys['KeyD']) {
                        this.socket.emit('ship-control', {
                            shipId: this.selectedShipId,
                            action: 'rudder-adjust',
                            value: 0.02
                        });
                    }
                    
                    // W/S for speed control
                    if (this.keys['KeyW']) {
                        this.socket.emit('ship-control', {
                            shipId: this.selectedShipId,
                            action: 'speed-adjust',
                            value: 0.5
                        });
                    }
                    if (this.keys['KeyS']) {
                        this.socket.emit('ship-control', {
                            shipId: this.selectedShipId,
                            action: 'speed-adjust',
                            value: -0.5
                        });
                    }
                }
            }
            
            updateSelectedShipDisplay(ship = null) {
                if (!ship && this.selectedShipId && this.gameState) {
                    ship = this.gameState.ships.find(s => s.id === this.selectedShipId);
                }
                
                if (ship) {
                    const teamName = ship.team === 'team1' ? 'Blue' : 'Red';
                    document.getElementById('selectedObject').textContent = 
                        `${teamName} Ship ${ship.shipNumber || ''} (${ship.ownerId === this.myPlayerId ? 'You' : 'Ally'})`;
                    
                    // Update sliders
                    const degrees = Math.round((ship.targetRudderAngle || 0) * 180/Math.PI);
                    document.getElementById('headingSlider').value = degrees;
                    document.getElementById('headingValue').textContent = degrees + '¬∞';
                    
                    document.getElementById('speedSlider').value = Math.round(ship.targetSpeed || 25);
                    document.getElementById('speedValue').textContent = Math.round(ship.targetSpeed || 25);
                } else {
                    document.getElementById('selectedObject').textContent = 'No selection';
                }
            }
            
            renderHeadingDisplay() {
                const ctx = this.headingCtx;
                const canvas = this.headingCanvas;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (!this.selectedShipId || !this.gameState) {
                    document.getElementById('currentHeading').textContent = 'Tiller: --';
                    document.getElementById('selectedObject').textContent = 'No selection';
                    return;
                }
                
                const ship = this.gameState.ships.find(s => s.id === this.selectedShipId);
                if (!ship) {
                    document.getElementById('currentHeading').textContent = 'Tiller: --';
                    document.getElementById('selectedObject').textContent = 'No selection';
                    return;
                }
                
                const tillerAngle = ship.rudderAngle || 0;
                const degrees = Math.round(tillerAngle * 180 / Math.PI);
                document.getElementById('currentHeading').textContent = `Tiller: ${degrees}¬∞`;
                
                // Update selected object info
                const shipNumber = ship.shipNumber || 1;
                const health = ship.health || 3;
                const maxHealth = ship.maxHealth || 3;
                const tier = ship.tier || 1;
                const teamName = ship.team === 'team1' ? 'Blue' : 'Red';
                document.getElementById('selectedObject').textContent = `Ship ${shipNumber} (T${tier}) ${teamName} - HP: ${health}/${maxHealth}`;
                
                // Draw the protractor
                const centerX = canvas.width / 2;
                const centerY = canvas.height - 20;
                const radius = 120;
                
                // Draw the semi-circle outline
                ctx.strokeStyle = '#4169E1';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, Math.PI, 0);
                ctx.stroke();
                
                // Draw degree markings
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.fillStyle = '#ccc';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                for (let tillerDeg = -45; tillerDeg <= 45; tillerDeg += 15) {
                    const protractorAngle = Math.PI * (1 - (tillerDeg + 45) / 90);
                    
                    const x1 = centerX + Math.cos(protractorAngle) * (radius - 15);
                    const y1 = centerY - Math.sin(protractorAngle) * (radius - 15);
                    const x2 = centerX + Math.cos(protractorAngle) * radius;
                    const y2 = centerY - Math.sin(protractorAngle) * radius;
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    
                    const labelX = centerX + Math.cos(protractorAngle) * (radius + 15);
                    const labelY = centerY - Math.sin(protractorAngle) * (radius + 15);
                    
                    if (tillerDeg === 0) {
                        ctx.fillText('0¬∞', labelX, labelY);
                    } else {
                        const sign = tillerDeg > 0 ? '+' : '';
                        ctx.fillText(sign + tillerDeg + '¬∞', labelX, labelY);
                    }
                }
                
                // Minor markings
                for (let tillerDeg = -40; tillerDeg <= 40; tillerDeg += 5) {
                    if (tillerDeg % 15 !== 0) {
                        const protractorAngle = Math.PI * (1 - (tillerDeg + 45) / 90);
                        
                        const x1 = centerX + Math.cos(protractorAngle) * (radius - 8);
                        const y1 = centerY - Math.sin(protractorAngle) * (radius - 8);
                        const x2 = centerX + Math.cos(protractorAngle) * radius;
                        const y2 = centerY - Math.sin(protractorAngle) * radius;
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
                
                // Draw the tiller indicator line
                const tillerDegrees = tillerAngle * 180 / Math.PI;
                const clampedTiller = Math.max(-45, Math.min(45, tillerDegrees));
                const protractorAngle = Math.PI * (1 - (clampedTiller + 45) / 90);
                
                const indicatorX = centerX + Math.cos(protractorAngle) * (radius - 5);
                const indicatorY = centerY - Math.sin(protractorAngle) * (radius - 5);
                
                const teamColor = ship.team === 'team1' ? '#4169E1' : '#DC143C';
                ctx.strokeStyle = teamColor;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(indicatorX, indicatorY);
                ctx.stroke();
                
                ctx.fillStyle = teamColor;
                ctx.beginPath();
                ctx.arc(indicatorX, indicatorY, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#4169E1';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Add center line for reference
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX, centerY - radius + 5);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            update(deltaTime) {
                if (!this.gameState) return;
                
                this.updateControls();
                this.renderHeadingDisplay();
                this.updateGameStatus();
                this.updateIcebergDrift(deltaTime);
            }
            
            updateGameStatus() {
                if (!this.gameState) return;
                
                if (this.gameState.gameStartTime) {
                    const elapsed = Math.floor((Date.now() - this.gameState.gameStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('gameTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
                
                document.getElementById('team1Score').textContent = this.gameState.scores?.team1 || 0;
                document.getElementById('team2Score').textContent = this.gameState.scores?.team2 || 0;
            }
            
            renderAnimatedOcean() {
                const time = Date.now() * 0.001; // Convert to seconds for wave animation
                
                // Base ocean color
                this.ctx.fillStyle = "#0f3460";
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Create animated wave patterns with depth
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, "#1e4a6f");
                gradient.addColorStop(0.3, "#0f3460");
                gradient.addColorStop(0.7, "#0a2847");
                gradient.addColorStop(1, "#051c2f");
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw animated wave lines
                this.ctx.strokeStyle = "rgba(32, 178, 170, 0.05)"; // Much more transparent
                this.ctx.lineWidth = 1;
                
                for (let i = 0; i < 8; i++) {
                    this.ctx.beginPath();
                    const waveOffset = time * (2 + i * 0.3); // Much slower waves
                    const amplitude = 8 + i * 2; // Smaller waves
                    const frequency = 0.003 + i * 0.0005; // Lower frequency
                    
                    for (let x = 0; x <= this.canvas.width; x += 5) {
                        const y = this.canvas.height * (0.2 + i * 0.1) + 
                                 Math.sin((x * frequency) + waveOffset) * amplitude;
                        if (x === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    this.ctx.stroke();
                }
                
                // Draw occasional sea birds
                this.drawSeaBirds(time);
                
                // Draw floating debris and seaweed patches
                this.drawFloatingDebris(time);
                
                // Add subtle floating particles/bubbles
                this.ctx.fillStyle = "rgba(135, 206, 235, 0.1)";
                for (let i = 0; i < 15; i++) {
                    const particleTime = time * (0.1 + i * 0.02); // Much slower particles
                    const x = (i * 73 + Math.sin(particleTime) * 15) % this.canvas.width; // Smaller movement
                    const y = (i * 47 + Math.cos(particleTime * 0.7) * 10) % this.canvas.height; // Smaller movement
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 2 + Math.sin(particleTime * 2) * 1, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            drawSeaBirds(time) {
                // Draw 2-3 birds occasionally
                for (let i = 0; i < 3; i++) {
                    const birdCycle = (time * 0.1 + i * 2.5) % 10; // 10 second cycle per bird
                    if (birdCycle > 8) continue; // Only show birds 80% of the cycle
                    
                    // Bird position moving across screen
                    const progress = birdCycle / 8;
                    const birdX = -50 + progress * (this.canvas.width + 100);
                    const birdY = 50 + Math.sin(time * 0.5 + i) * 20 + i * 30;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.6;
                    this.ctx.fillStyle = "#2c3e50";
                    
                    // Simple bird shape (V shape)
                    const wingSpread = 8 + Math.sin(time * 3 + i) * 2;
                    this.ctx.beginPath();
                    // Left wing
                    this.ctx.moveTo(birdX - wingSpread, birdY);
                    this.ctx.lineTo(birdX - 2, birdY - 3);
                    this.ctx.lineTo(birdX, birdY);
                    // Right wing  
                    this.ctx.lineTo(birdX + 2, birdY - 3);
                    this.ctx.lineTo(birdX + wingSpread, birdY);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            drawFloatingDebris(time) {
                // Draw small patches of floating seaweed and debris
                for (let i = 0; i < 6; i++) {
                    const debrisX = (Math.sin(time * 0.05 + i * 1.2) + 1) * this.canvas.width * 0.4 + this.canvas.width * 0.1;
                    const debrisY = (Math.cos(time * 0.03 + i * 1.8) + 1) * this.canvas.height * 0.4 + this.canvas.height * 0.1;
                    const driftX = Math.sin(time * 0.1 + i) * 2;
                    const driftY = Math.cos(time * 0.08 + i) * 1.5;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.fillStyle = i % 2 === 0 ? "#1a5f3f" : "#8B4513"; // Seaweed green or driftwood brown
                    
                    // Draw small irregular patch
                    this.ctx.beginPath();
                    for (let j = 0; j < 8; j++) {
                        const angle = (j / 8) * Math.PI * 2;
                        const radius = 3 + Math.sin(time * 0.5 + i + j) * 2;
                        const x = debrisX + driftX + Math.cos(angle) * radius;
                        const y = debrisY + driftY + Math.sin(angle) * radius;
                        
                        if (j === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            drawShipWake(ship, speed) {
                const wakeLength = Math.min(speed * 20, 60);
                const wakeWidth = Math.min(speed * 3, 12);
                
                // Calculate wake direction (opposite of ship movement)
                const wakeAngle = Math.atan2(-ship.vy || 0, -ship.vx || 0);
                
                this.ctx.save();
                this.ctx.globalAlpha = 0.4;
                
                // Draw foam trail behind ship
                for (let i = 0; i < 5; i++) {
                    const distance = 15 + i * (wakeLength / 5);
                    const wakeX = ship.x + Math.cos(wakeAngle) * distance;
                    const wakeY = ship.y + Math.sin(wakeAngle) * distance;
                    const fadeAlpha = (5 - i) / 5 * 0.3;
                    const currentWidth = wakeWidth * (5 - i) / 5;
                    
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${fadeAlpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(wakeX, wakeY, currentWidth, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (!this.gameState) {
                    this.renderAnimatedOcean();
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '24px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Waiting for game state...', this.canvas.width/2, this.canvas.height/2);
                    return;
                }
                
                // Animated ocean background
                this.renderAnimatedOcean();
                
                // Render obstacles
                if (this.gameState.obstacles) {
                    for (let obstacle of this.gameState.obstacles) {
                        this.ctx.save();
                        this.ctx.translate(obstacle.x, obstacle.y);
                        
                        // Draw elevation shadow first (proportional to obstacle size)
                        const shadowOffset = obstacle.radius * 0.25;
                        const shadowRadius = obstacle.radius * 0.8;
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                        this.ctx.beginPath();
                        this.ctx.ellipse(shadowOffset, shadowOffset, shadowRadius, shadowRadius * 0.5, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        if (obstacle.type === 'island') {
                            // Draw island image
                            const islandImg = this.getIslandImage(obstacle.imageIndex);
                            if (islandImg) {
                                const size = obstacle.radius * 2;
                                this.ctx.drawImage(islandImg, -size/2, -size/2, size, size);
                            }
                        } else if (obstacle.type === 'iceberg') {
                            // Draw iceberg image
                            const icebergImg = this.getIcebergImage(obstacle.imageIndex);
                            if (icebergImg) {
                                const size = obstacle.radius * 2;
                                this.ctx.drawImage(icebergImg, -size/2, -size/2, size, size);
                            }
                        }
                        
                        this.ctx.restore();
                    }
                }
                
                // Render docks using server-provided spawn points
                const team1Dock = this.gameState.spawnPoints?.team1 || { x: 100, y: 620 };
                const team2Dock = this.gameState.spawnPoints?.team2 || { x: 900, y: 80 };
                
                // Team 1 dock (blue)
                this.ctx.save();
                this.ctx.fillStyle = 'rgba(65, 105, 225, 0.4)';
                this.ctx.beginPath();
                this.ctx.arc(team1Dock.x, team1Dock.y, 35, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.fillStyle = '#4169E1';
                this.ctx.beginPath();
                this.ctx.arc(team1Dock.x, team1Dock.y, 25, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Team 2 dock (red)
                this.ctx.fillStyle = 'rgba(220, 20, 60, 0.4)';
                this.ctx.beginPath();
                this.ctx.arc(team2Dock.x, team2Dock.y, 35, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.fillStyle = '#DC143C';
                this.ctx.beginPath();
                this.ctx.arc(team2Dock.x, team2Dock.y, 25, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.restore();
                
                // Render ships
                if (this.gameState.ships) {
                    for (let ship of this.gameState.ships) {
                        // Draw wake effect behind moving ships
                        if (ship.vx || ship.vy) {
                            const speed = Math.sqrt((ship.vx || 0) * (ship.vx || 0) + (ship.vy || 0) * (ship.vy || 0));
                            if (speed > 0.5) { // Only draw wake for ships moving fast enough
                                this.drawShipWake(ship, speed);
                            }
                        }
                        
                        this.ctx.save();
                        this.ctx.translate(ship.x, ship.y);
                        
                        // Draw ship shadow first
                        const shadowOffset = 5;
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                        this.ctx.beginPath();
                        this.ctx.ellipse(shadowOffset, shadowOffset, 20, 12, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Draw ship image based on team and angle
                        const shipImg = this.getShipImage(ship.team, ship.angle);
                        if (shipImg) {
                            // Draw ship image centered at origin
                            const shipSize = 60; // Size of ship image
                            this.ctx.drawImage(shipImg, -shipSize/2, -shipSize/2, shipSize, shipSize);
                        } else {
                            // Fallback to colored rectangles if image not loaded
                            let fillColor, darkColor;
                            if (ship.team === 'team1') {
                                fillColor = '#4169E1';
                                darkColor = '#00008B';
                            } else if (ship.team === 'team2') {
                                fillColor = '#DC143C';
                                darkColor = '#8B0000';
                            } else {
                                // Neutral ships - use white/gray
                                fillColor = '#FFFFFF';
                                darkColor = '#CCCCCC';
                            }
                            
                            this.ctx.fillStyle = fillColor;
                            this.ctx.fillRect(-24, -24, 48, 48);
                            
                            this.ctx.fillStyle = darkColor;
                            this.ctx.fillRect(12, -12, 12, 24);
                            
                            this.ctx.strokeStyle = '#000';
                            this.ctx.lineWidth = 1;
                            this.ctx.strokeRect(-24, -24, 48, 48);
                        }
                        
                        // Selection highlighting (drawn first, in ship coordinate space)
                        if (ship.id === this.selectedShipId) {
                            // Enhanced selection highlighting
                            this.ctx.strokeStyle = '#FFFF00';
                            this.ctx.lineWidth = 4;
                            this.ctx.strokeRect(-24, -24, 48, 48);
                            
                            // Add a pulsing outer glow effect
                            const time = Date.now() / 500;
                            const alpha = 0.3 + 0.2 * Math.sin(time);
                            this.ctx.shadowColor = '#FFFF00';
                            this.ctx.shadowBlur = 10;
                            this.ctx.globalAlpha = alpha;
                            this.ctx.strokeStyle = '#FFFFFF';
                            this.ctx.lineWidth = 2;
                            this.ctx.strokeRect(-30, -30, 60, 60);
                            this.ctx.shadowBlur = 0;
                            this.ctx.globalAlpha = 1;
                        }
                        
                        this.ctx.restore();
                        
                        // Health bar - only show for ships owned by this player (drawn after selection to appear on top)
                        if (ship.ownerId === this.myPlayerId) {
                            this.ctx.save();
                            this.ctx.translate(ship.x, ship.y - 20);
                            
                            const healthRatio = ship.health / ship.maxHealth;
                            
                            // Health bar background (larger and more visible)
                            this.ctx.fillStyle = '#333';
                            this.ctx.fillRect(-12, 0, 24, 5);
                            
                            // Health bar
                            this.ctx.fillStyle = healthRatio > 0.66 ? '#00FF00' : healthRatio > 0.33 ? '#FFFF00' : '#FF0000';
                            this.ctx.fillRect(-12, 0, healthRatio * 24, 5);
                            
                            // Health bar border
                            this.ctx.strokeStyle = '#000';
                            this.ctx.lineWidth = 1;
                            this.ctx.strokeRect(-12, 0, 24, 5);
                            
                            this.ctx.restore();
                        }
                        
                        this.ctx.restore();
                    }
                    
                    // Render ship numbers
                    for (let ship of this.gameState.ships) {
                        if (ship.shipNumber) {
                            const numberX = ship.x - 15;
                            const numberY = ship.y + 15;
                            
                            this.ctx.save();
                            
                            // Make selected ship number larger and more prominent
                            const isSelected = ship.id === this.selectedShipId;
                            const fontSize = isSelected ? 24 : 18;
                            let fillColor = ship.team === 'team1' ? '#4169E1' : '#DC143C';
                            if (isSelected) {
                                fillColor = '#FFFF00';
                            }
                            const strokeWidth = isSelected ? 3 : 2;
                            
                            this.ctx.fillStyle = fillColor;
                            this.ctx.strokeStyle = '#000';
                            this.ctx.lineWidth = strokeWidth;
                            this.ctx.font = `bold ${fontSize}px Arial`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            
                            this.ctx.strokeText(ship.shipNumber.toString(), numberX, numberY);
                            this.ctx.fillText(ship.shipNumber.toString(), numberX, numberY);
                            
                            this.ctx.restore();
                        }
                        
                        // Render tier stars (T2+ only)
                        if (ship.tier && ship.tier > 1) {
                            this.ctx.save();
                            this.ctx.translate(ship.x, ship.y - 35);
                            
                            const starCount = Math.min(ship.tier - 1, 3); // T2=1 star, T3=2 stars, T4=3 stars
                            const starSize = 8;
                            const spacing = 16;
                            const startX = -(starCount - 1) * spacing / 2;
                            
                            for (let i = 0; i < starCount; i++) {
                                const x = startX + i * spacing;
                                
                                // Draw large filled circle as "star"
                                this.ctx.fillStyle = '#FFD700'; // Gold
                                this.ctx.beginPath();
                                this.ctx.arc(x, 0, starSize, 0, Math.PI * 2);
                                this.ctx.fill();
                                
                                // Black border
                                this.ctx.strokeStyle = '#000';
                                this.ctx.lineWidth = 2;
                                this.ctx.stroke();
                                
                                // White center dot
                                this.ctx.fillStyle = '#FFFFFF';
                                this.ctx.beginPath();
                                this.ctx.arc(x, 0, 3, 0, Math.PI * 2);
                                this.ctx.fill();
                            }
                            
                            this.ctx.restore();
                        }
                    }
                    
                    // Render cannon directions
                    for (let ship of this.gameState.ships) {
                        if (ship.ownerId === this.myPlayerId) {
                            this.ctx.strokeStyle = '#FF0000';
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.moveTo(ship.x, ship.y);
                            this.ctx.lineTo(
                                ship.x + Math.cos(ship.cannonAngle) * 50,
                                ship.y + Math.sin(ship.cannonAngle) * 50
                            );
                            this.ctx.stroke();
                            
                            if (ship.id === this.selectedShipId) {
                                this.ctx.strokeStyle = '#FFFF00';
                                this.ctx.lineWidth = 2;
                                this.ctx.setLineDash([5, 5]);
                                this.ctx.beginPath();
                                this.ctx.moveTo(ship.x, ship.y);
                                this.ctx.lineTo(
                                    ship.x + Math.cos(this.mouseAimAngle) * 50,
                                    ship.y + Math.sin(this.mouseAimAngle) * 50
                                );
                                this.ctx.stroke();
                                this.ctx.setLineDash([]);
                            }
                        } else {
                            // Show other players' cannon directions
                            const color = ship.team === 'team1' ? '#4444FF' : '#FF4444';
                            this.ctx.strokeStyle = color;
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.moveTo(ship.x, ship.y);
                            this.ctx.lineTo(
                                ship.x + Math.cos(ship.cannonAngle) * 50,
                                ship.y + Math.sin(ship.cannonAngle) * 50
                            );
                            this.ctx.stroke();
                        }
                    }
                }
                
                // Render cannonballs
                if (this.gameState.cannonballs) {
                    for (let cannonball of this.gameState.cannonballs) {
                        this.ctx.fillStyle = '#1a1a1a';
                        this.ctx.beginPath();
                        this.ctx.arc(cannonball.x, cannonball.y, 4, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        this.ctx.strokeStyle = '#fff';
                        this.ctx.lineWidth = 1;
                        this.ctx.stroke();
                    }
                }
                
                // Update heading display for selected ship
                this.renderHeadingDisplay();
            }
            

            gameLoop() {
                const currentTime = performance.now();
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                
                                   // Update animation frame every 0.25 seconds (250ms)
                   if (currentTime - this.lastAnimationUpdate >= 250) {
                     this.animationFrame = (this.animationFrame + 1) % 4; // Cycle through 0, 1, 2, 3
                     this.lastAnimationUpdate = currentTime;
                   }
                
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        window.addEventListener('load', () => {
            window.game = new NavalBattleMultiplayer();
        });
    </script>
</body>
</html>