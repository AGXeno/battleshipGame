<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Naval Battle - Easy vs Hard AI Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            overflow: auto;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            background: #1a1a2e;
            min-height: 900px;
            padding-top: 20px;
        }
        
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #0f3460;
            cursor: crosshair;
            z-index: 1;
        }
        
        #topScore {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            padding: 15px 25px;
            font-size: 28px;
            color: white;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        #dualDashboardContainer {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            z-index: 10;
            transition: opacity 0.3s ease;
        }
        
        #dualDashboardContainer.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .aiDashboard {
            width: 220px;
            height: 200px;
            background: rgba(0, 0, 0, 0.1);
            border: 2px solid #16213e;
            border-radius: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #blueDashboard {
            border-color: #4169E1;
        }
        
        #redDashboard {
            border-color: #DC143C;
        }
        
        .dashboardHeader {
            text-align: center;
            margin-bottom: 10px;
            color: white;
        }
        
        .teamTitle {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        #blueDashboard .teamTitle {
            color: #4169E1;
        }
        
        #redDashboard .teamTitle {
            color: #DC143C;
        }
        
        .shipInfo {
            font-size: 14px;
            color: #ccc;
        }
        
        #gameStatus {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
        }
        
        #gameMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #16213e;
            border-radius: 15px;
            padding: 30px;
            color: white;
            text-align: center;
            z-index: 200;
            min-width: 300px;
        }
        
        #gameMenu.hidden {
            display: none;
        }
        
        #gameMenu h2 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #4169E1;
            font-size: 2em;
        }
        
        #gameMenu h2.countdown {
            font-size: 6em;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            margin: 0;
        }
        
        #demoControls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            color: white;
            text-align: center;
        }
        
        #controlsToggle {
            position: absolute;
            bottom: 120px;
            left: 10px;
            z-index: 100;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #16213e;
            color: white;
            cursor: pointer;
        }
        
        #speedBtn {
            position: absolute;
            top: 750px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #ff8c00;
            color: white;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
        }
        
        #speedBtn:hover {
            background: #ff7700;
        }
        
        #dashboardToggle {
            position: fixed;
            top: 120px;
            right: 20px;
            padding: 10px 15px;
            background: #16213e;
            border: 2px solid #4169E1;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            z-index: 20;
        }
        
        #dashboardToggle:hover {
            background: #1e3a5f;
        }
        
        #controlsPanel {
            position: absolute;
            left: 10px;
            bottom: 60px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #16213e;
            border-radius: 8px;
            padding: 15px;
            color: white;
            max-width: 300px;
            transition: transform 0.3s ease;
            z-index: 99;
        }
        
        #controlsPanel.hidden {
            transform: translateX(-100%);
        }
        
        .score-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
            min-width: 200px;
        }
        
        .blue-score {
            color: #4169E1;
        }
        
        .red-score {
            color: #DC143C;
        }
        
        .game-info {
            color: #ccc;
            font-size: 28px;
        }
        
        .ship-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }
        
        input[type="range"] {
            width: 80px;
        }
        
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: #16213e;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }
        
        button:hover {
            background: #1e3a5f;
        }
        
        .demo-info {
            font-size: 14px;
            color: #ccc;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Background Music Audio Element -->
        <audio id="backgroundMusic" loop>
            <source src="Assets/Audio/background_audio.wav" type="audio/wav">
            Your browser does not support the audio element.
        </audio>
        
        <!-- Cannon Fire Sound Elements -->
        <audio id="cannonSound1" preload="auto">
            <source src="Assets/Audio/ship-fire/fire-1.wav" type="audio/wav">
        </audio>
        <audio id="cannonSound2" preload="auto">
            <source src="Assets/Audio/ship-fire/fire-2.wav" type="audio/wav">
        </audio>
        <audio id="cannonSound3" preload="auto">
            <source src="Assets/Audio/ship-fire/fire-3.wav" type="audio/wav">
        </audio>
        <audio id="cannonSound5" preload="auto">
            <source src="Assets/Audio/ship-fire/fire-5.wav" type="audio/wav">
        </audio>
        
        <div id="topScore">
            <div class="score-item blue-score">
                Blue AI Ships Sunk: <span id="blueScore">0</span>
            </div>
            <div class="score-item game-info">
                Time: <span id="gameTime">0:00</span>
            </div>
            <div class="score-item red-score">
                Red AI Ships Sunk: <span id="redScore">0</span>
            </div>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        
        <div id="dualDashboardContainer">
            <div id="blueDashboard" class="aiDashboard">
                <div class="dashboardHeader">
                    <div class="teamTitle">Blue AI Team</div>
                    <div class="shipInfo" id="blueShipInfo">Ship 1</div>
                </div>
                <canvas id="blueHeadingCanvas" width="200" height="150"></canvas>
            </div>
            
            <div id="redDashboard" class="aiDashboard">
                <div class="dashboardHeader">
                    <div class="teamTitle">Red AI Team</div>
                    <div class="shipInfo" id="redShipInfo">Ship 1</div>
                </div>
                <canvas id="redHeadingCanvas" width="200" height="150"></canvas>
            </div>
        </div>
        
        <div id="demoControls">
            <div><strong>🎬 AI Battle Demo</strong></div>
            <div class="demo-info">
                Blue team: HARD AI vs Red team: HARD AI - Watch advanced tactical combat!
            </div>
        </div>
        
        <div id="gameMenu">
            <h2 id="menuTitle">Naval Battle Demo</h2>
            <div id="menuContent">
                <button id="startBtn">Start Demo</button>
                <button id="resetBtn">Reset Demo</button>
                <button onclick="window.location.href='/'">← Main Menu</button>
            </div>
        </div>
        
        <button id="controlsToggle">About This Demo</button>
        <button id="speedBtn">Speed: 1x</button>
        <button id="dashboardToggle">Hide Dashboard</button>
        
        <div id="controlsPanel" class="hidden">
            <div><strong>AI Battle Demo:</strong></div>
            <div>• Blue AI: Aggressive strategy (Hard)</div>
            <div>• Red AI: Defensive strategy (Hard)</div>
            <div>• Advanced obstacle avoidance</div>
            <div>• Predictive aiming</div>
            <div>• Strategic positioning</div>
            <div>• Ships auto-fire every 5 seconds</div>
            <div>• First team to 15 points wins</div>
            <div>• Ramming damage enabled</div>
            <div>• Drifting icebergs</div>
            <div>• White neutral ships with power-ups</div>
            <div>• Ship upgrade system with stars</div>
            <br>
            <div><strong>AI Behaviors:</strong></div>
            <div>• Attack: Maintain optimal range</div>
            <div>• Evade: Zigzag patterns</div>
            <div>• Patrol: Figure-8 movement</div>
            <br>
            <div><strong>New Features:</strong></div>
            <div>• Neutral ships target highest tier ships</div>
            <div>• Power-ups: Health (+), Damage (⚡), Rate (⟲), Speed (→)</div>
            <div>• Ship tiers shown as gold stars</div>
            
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #333;">
                <div style="font-weight: bold; margin-bottom: 8px;">Sound Controls:</div>
                
                <div class="ship-controls">
                    <label>Music: </label>
                    <button id="musicToggle" style="padding: 2px 8px; font-size: 11px; margin: 0 5px;">On</button>
                </div>
                
                <div class="ship-controls">
                    <label>Music Vol: </label>
                    <input type="range" id="musicVolumeSlider" min="0" max="100" value="50" style="width: 80px;" />
                    <span id="musicVolumeValue">50%</span>
                </div>
                
                <div class="ship-controls">
                    <label>Sound Effects: </label>
                    <button id="soundToggle" style="padding: 2px 8px; font-size: 11px; margin: 0 5px;">On</button>
                </div>
                
                <div class="ship-controls">
                    <label>Sound Vol: </label>
                    <input type="range" id="soundVolumeSlider" min="0" max="100" value="70" style="width: 80px;" />
                    <span id="soundVolumeValue">70%</span>
                </div>
                
                <div class="ship-controls" style="margin-top: 10px;">
                    <button id="testAudioBtn" style="padding: 5px 10px; font-size: 12px; background: #4169E1;">Test Audio</button>
                </div>
            </div>
            
            <button onclick="document.getElementById('controlsPanel').classList.add('hidden')" 
                    style="margin-top: 10px; padding: 5px 10px; font-size: 12px;">
                Hide Info
            </button>
        </div>
    </div>

    <script>
        // Game Constants
        // Scaling factors for resolution upgrade
        const SCALE_X = 1.92; // 1920/1000
        const SCALE_Y = 1.543; // 1080/700
        const SCALE_AVG = (SCALE_X + SCALE_Y) / 2; // Average for general scaling
        
        // Debug: Log the actual values
        console.log('SCALE_AVG:', SCALE_AVG);
        console.log('Ship Radius:', Math.round(24 * SCALE_AVG));
        console.log('Ship Speed (base):', Math.round(25 * SCALE_AVG));

        const GAME_CONFIG = {
            // Ship Properties (scaled for higher resolution)
            SHIP_DEFAULT_SPEED: Math.round(25 * SCALE_AVG),
            SHIP_MAX_HEALTH: 3,
            SHIP_RADIUS: Math.round(20 * SCALE_AVG),
            SHIP_CANNON_COOLDOWN: 5000,
            SHIP_RAM_COOLDOWN: 1000,
            SHIP_SPEED_CHANGE_RATE: Math.round(15 * SCALE_AVG),
            SHIP_BASE_TURN_RATE: 0.8,
            SHIP_SPAWN_DELAY: 5000,
            
            // Cannonball Properties (scaled)
            CANNONBALL_SPEED: Math.round(80 * SCALE_AVG),
            CANNONBALL_RADIUS: Math.round(3 * SCALE_AVG),
            CANNONBALL_RANGE: Math.round(1000 * SCALE_AVG),
            
            // Obstacle Properties (scaled)
            OBSTACLE_MIN_RADIUS: Math.round(20 * SCALE_AVG),
            OBSTACLE_MAX_RADIUS: Math.round(35 * SCALE_AVG),
            OBSTACLE_DAMAGE_RADIUS: Math.round(12 * SCALE_AVG),
            OBSTACLE_DAMAGE_AMOUNT: 0.1,
            OBSTACLE_PUSH_FORCE: Math.round(15 * SCALE_AVG),
            OBSTACLE_DESTRUCTIBLE_HEALTH: 10,
            OBSTACLE_LARGE_MIN_RADIUS: Math.round(30 * SCALE_AVG),
            OBSTACLE_LARGE_MAX_RADIUS: Math.round(50 * SCALE_AVG),
            
            // AI Behavior (scaled)
            AI_ATTACK_RANGE: Math.round(150 * SCALE_AVG),
            AI_AVOIDANCE_RANGE: Math.round(30 * SCALE_AVG),
            AI_PREDICTIVE_AVOIDANCE_RANGE: Math.round(30 * SCALE_AVG),
            
            // AI Difficulty Settings
            AI_DIFFICULTY: {
                EASY: {
                    powerUpAwareness: 0.2,      // 20% chance to go for power-ups
                    aggressionLevel: 0.6,       // Less aggressive
                    reactionTime: 2000,         // Slower reactions
                    aimAccuracy: 0.7,           // Less accurate
                    strategicThinking: 0.1,     // Poor strategic decisions
                    neutralShipPriority: 0.3    // Low priority on neutral ships
                },
                MEDIUM: {
                    powerUpAwareness: 0.5,      // 50% chance to go for power-ups
                    aggressionLevel: 0.8,       // Standard aggression
                    reactionTime: 1500,         // Standard reactions
                    aimAccuracy: 0.85,          // Good accuracy
                    strategicThinking: 0.5,     // Moderate strategic thinking
                    neutralShipPriority: 0.6    // Moderate priority on neutral ships
                },
                HARD: {
                    powerUpAwareness: 0.9,      // 90% chance to go for power-ups
                    aggressionLevel: 1.2,       // Highly aggressive
                    reactionTime: 800,          // Fast reactions
                    aimAccuracy: 0.95,          // High accuracy
                    strategicThinking: 0.9,     // Excellent strategic decisions
                    neutralShipPriority: 0.9    // High priority on neutral ships
                }
            },
            
            // UI and Rendering
            CANVAS_WIDTH: 1920,
            CANVAS_HEIGHT: 1080,
            HEADING_COMPASS_RADIUS: 120,
            HEALTH_BAR_WIDTH: Math.round(24 * SCALE_AVG),
            HEALTH_BAR_HEIGHT: Math.round(5 * SCALE_AVG),
            
            // Physics and Movement
            DELTA_TIME_MULTIPLIER: 0.001,
            ICEBERG_DRIFT_MIN_SPEED: 3.5,
            ICEBERG_DRIFT_MAX_SPEED: 7.5,
            
            // Map boundaries (larger than canvas for off-screen spawning)
            MAP_WIDTH: 1200,  // 200px beyond canvas on each side
            MAP_HEIGHT: 900,  // 100px beyond canvas on each side
            
            // Audio
            AUDIO_DEFAULT_MUSIC_VOLUME: 0.5,
            AUDIO_DEFAULT_SOUND_VOLUME: 0.7,
            
            // Performance Optimization
            SPATIAL_GRID_SIZE: 100,
            CANNONBALL_POOL_SIZE: 50,
            TARGET_FPS: 60,
            
            // Neutral Ships and Upgrades
            NEUTRAL_SHIP_SPAWN_CHANCE: 0.9,
            NEUTRAL_SHIP_SPAWN_INTERVAL: 15000, // 15 seconds (less frequent)
            NEUTRAL_SHIP_SPEED: Math.round(25 * SCALE_AVG),
            NEUTRAL_SHIP_MAX_HEALTH: 3,
            MAX_SHIP_TIER: 3,
            UPGRADE_HEALTH_BONUS: 1,
            UPGRADE_DAMAGE_MULTIPLIER: 1.5,
            UPGRADE_RATE_OF_FIRE_BONUS: 0.7,
            UPGRADE_SPEED_MULTIPLIER: 1.3
        };

        class NavalBattleDemo {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Set canvas to full window size
                this.resizeCanvas();
                
                // Listen for window resize
                window.addEventListener('resize', () => this.resizeCanvas());
                
                console.log('Canvas actual size:', this.canvas.width, 'x', this.canvas.height);
                console.log('Scale factor being used:', this.SCALE_AVG);
                
                // Dual dashboard canvases
                this.blueCanvas = document.getElementById('blueHeadingCanvas');
                this.blueCtx = this.blueCanvas.getContext('2d');
                this.redCanvas = document.getElementById('redHeadingCanvas');
                this.redCtx = this.redCanvas.getContext('2d');
                
                // Audio elements
                this.backgroundMusic = document.getElementById('backgroundMusic');
                this.cannonSound1 = document.getElementById('cannonSound1');
                this.cannonSound2 = document.getElementById('cannonSound2');
                this.cannonSound3 = document.getElementById('cannonSound3');
                this.cannonSound5 = document.getElementById('cannonSound5');
                
                // Debug audio elements
                console.log('Audio elements found:');
                console.log('backgroundMusic:', this.backgroundMusic);
                console.log('cannonSound1:', this.cannonSound1);
                console.log('cannonSound2:', this.cannonSound2);
                console.log('cannonSound3:', this.cannonSound3);
                console.log('cannonSound5:', this.cannonSound5);
                
                this.gameState = {
                    ships: [],
                    cannonballs: [],
                    obstacles: [],
                    players: {
                        blue: { score: 0, dock: { x: 100, y: 620, spawnAngle: -45 * Math.PI/180 }, shipCount: 0, aiType: 'balanced', difficulty: 'HARD' }, // Will be updated by generateRandomSpawnPoints
                        red: { score: 0, dock: { x: 900, y: 80, spawnAngle: 135 * Math.PI/180 }, shipCount: 0, aiType: 'balanced', difficulty: 'HARD' } // Will be updated by generateRandomSpawnPoints
                    },
                    selectedObject: null,
                    selectedObjectType: null,
                    gameStarted: false,
                    gamePaused: false,
                    gameStartTime: null,
                    countdown: 0,
                    countdownActive: false,
                    pauseStartTime: null,
                    totalPausedTime: 0,
                    audio: {
                        musicEnabled: true,
                        musicVolume: 0.5,
                        musicStarted: false,
                        soundEnabled: true,
                        soundVolume: 0.7,
                        cannonSounds: []
                    }
                };
                
                this.lastTime = 0;
                this.selectedShipIndex = 0;
                this.blueAISelectedShipIndex = 0;
                this.redAISelectedShipIndex = 0;
                this.blueAILastShipSwitch = 0;
                this.redAILastShipSwitch = 0;
                this.lastIcebergSpawn = 0;
                this.icebergSpawnCooldown = 10000;
                this.spawnTimeouts = [];
                this.cameraFollowShip = null;
                this.speedMultiplier = 1; // Speed control for development
                
                // AI Demo tracking variables - track both teams separately
                this.blueSelectedShip = null;
                this.redSelectedShip = null;
                this.blueShipIndex = 0;
                this.redShipIndex = 0;
                this.autoSwitchInterval = 5000; // Auto-switch ships every 5 seconds
                this.lastBlueSwitchTime = 0;
                this.lastRedSwitchTime = 0;
                this.animationFrame = 0; // Current animation frame (0-3)
                this.lastAnimationUpdate = 0; // Last time animation frame was updated
                
                this.init();
            }

            // Image loading and management methods
            loadImages() {
                this.islandImages = [];
                this.icebergImages = [];
                this.shipImages = {
                    red: {},
                    blue: {},
                    white: {}
                };
                
                          // Load island images (6 total: 0-5)
          for (let i = 0; i < 6; i++) {
            const img = new Image();
            img.src = `Assets/Visuals/Islands/Island ${i}.png`;
            this.islandImages.push(img);
          }
          
          // Load iceberg images (12 total: 0-11)
          for (let i = 0; i < 12; i++) {
            const img = new Image();
            img.src = `Assets/Visuals/Icebergs/Iceberg ${i}.png`;
            this.icebergImages.push(img);
          }
                
                          // Load ship images for each color and direction (4 animation frames each)
          const shipColors = ['Red', 'Blue', 'White'];
          const shipDirections = ['East', 'NorthEast', 'North', 'NorthWest', 'West', 'SouthWest', 'South', 'SouthEast'];
          
          shipColors.forEach(color => {
            shipDirections.forEach(direction => {
              if (!this.shipImages[color.toLowerCase()]) {
                this.shipImages[color.toLowerCase()] = {};
              }
              if (!this.shipImages[color.toLowerCase()][direction]) {
                this.shipImages[color.toLowerCase()][direction] = [];
              }
              
              // Load all 4 animation frames (0, 1, 2, 3)
              for (let frame = 0; frame < 4; frame++) {
                const img = new Image();
                img.src = `Assets/Visuals/${color}Ship/${color}_Ship_${direction}/${color}_Ship_${direction}_${frame}.png`;
                this.shipImages[color.toLowerCase()][direction].push(img);
              }
            });
          });
            }

            getIslandImage(index) {
                return this.islandImages[index] || this.islandImages[0];
            }

            getIcebergImage(index) {
                return this.icebergImages[index] || this.icebergImages[0];
            }
            
            getShipImage(playerId, angle) {
                // Convert angle to degrees and normalize to 0-360
                let degrees = (angle * 180 / Math.PI) % 360;
                if (degrees < 0) degrees += 360;
                
                // Corrected direction mapping
                let direction;
                if (degrees >= 337.5 || degrees < 22.5) {
                    direction = 'East';
                } else if (degrees >= 22.5 && degrees < 67.5) {
                    direction = 'SouthEast';
                } else if (degrees >= 67.5 && degrees < 112.5) {
                    direction = 'South';
                } else if (degrees >= 112.5 && degrees < 157.5) {
                    direction = 'SouthWest';
                } else if (degrees >= 157.5 && degrees < 202.5) {
                    direction = 'West';
                } else if (degrees >= 202.5 && degrees < 247.5) {
                    direction = 'NorthWest';
                } else if (degrees >= 247.5 && degrees < 292.5) {
                    direction = 'North';
                } else if (degrees >= 292.5 && degrees < 337.5) {
                    direction = 'NorthEast';
                }
                
                // Determine ship color based on playerId
                let color;
                if (playerId === 'blue') {
                    color = 'blue';
                } else if (playerId === 'red') {
                    color = 'red';
                } else {
                    color = 'white'; // Treat all other cases as neutral
                }
                
                // Return the current animation frame
                const shipImageArray = this.shipImages[color]?.[direction];
                if (shipImageArray && shipImageArray.length > 0) {
                    return shipImageArray[this.animationFrame] || shipImageArray[0];
                }
                return null;
            }
            
            drawShipWake(ship, speed) {
                const wakeLength = Math.min(speed * 20, 60);
                const wakeWidth = Math.min(speed * 3, 12);
                
                // Calculate wake direction (opposite of ship movement)
                const wakeAngle = Math.atan2(-ship.vy, -ship.vx);
                
                this.ctx.save();
                this.ctx.globalAlpha = 0.4;
                
                // Draw foam trail behind ship
                for (let i = 0; i < 5; i++) {
                    const distance = 15 + i * (wakeLength / 5);
                    const wakeX = ship.x + Math.cos(wakeAngle) * distance;
                    const wakeY = ship.y + Math.sin(wakeAngle) * distance;
                    const fadeAlpha = (5 - i) / 5 * 0.3;
                    const currentWidth = wakeWidth * (5 - i) / 5;
                    
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${fadeAlpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(wakeX, wakeY, currentWidth, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }
            
            drawSeaBirds(time) {
                // Draw 2-3 birds occasionally
                for (let i = 0; i < 3; i++) {
                    const birdCycle = (time * 0.1 + i * 2.5) % 10; // 10 second cycle per bird
                    if (birdCycle > 8) continue; // Only show birds 80% of the cycle
                    
                    // Bird position moving across screen
                    const progress = birdCycle / 8;
                    const birdX = -50 + progress * (this.canvas.width + 100);
                    const birdY = 50 + Math.sin(time * 0.5 + i) * 20 + i * 30;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.6;
                    this.ctx.fillStyle = "#2c3e50";
                    
                    // Simple bird shape (V shape)
                    const wingSpread = 8 + Math.sin(time * 3 + i) * 2;
                    this.ctx.beginPath();
                    // Left wing
                    this.ctx.moveTo(birdX - wingSpread, birdY);
                    this.ctx.lineTo(birdX - 2, birdY - 3);
                    this.ctx.lineTo(birdX, birdY);
                    // Right wing  
                    this.ctx.lineTo(birdX + 2, birdY - 3);
                    this.ctx.lineTo(birdX + wingSpread, birdY);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            drawFloatingDebris(time) {
                // Draw small patches of floating seaweed and debris
                for (let i = 0; i < 6; i++) {
                    const debrisX = (Math.sin(time * 0.05 + i * 1.2) + 1) * this.canvas.width * 0.4 + this.canvas.width * 0.1;
                    const debrisY = (Math.cos(time * 0.03 + i * 1.8) + 1) * this.canvas.height * 0.4 + this.canvas.height * 0.1;
                    const driftX = Math.sin(time * 0.1 + i) * 2;
                    const driftY = Math.cos(time * 0.08 + i) * 1.5;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.fillStyle = i % 2 === 0 ? "#1a5f3f" : "#8B4513"; // Seaweed green or driftwood brown
                    
                    // Draw small irregular patch
                    this.ctx.beginPath();
                    for (let j = 0; j < 8; j++) {
                        const angle = (j / 8) * Math.PI * 2;
                        const radius = 3 + Math.sin(time * 0.5 + i + j) * 2;
                        const x = debrisX + driftX + Math.cos(angle) * radius;
                        const y = debrisY + driftY + Math.sin(angle) * radius;
                        
                        if (j === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            init() {
                this.loadImages();
                this.setupCanvas();
                this.setupControls();
                this.generateRandomSpawnPoints();
                this.generateObstacles();
                this.gameLoop();
            }
            
            setupCanvas() {
                // Demo is view-only, no interaction needed
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
            }
            
            handleCanvasClick(e) {
                // Click to follow different ships in demo
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                for (let ship of this.gameState.ships) {
                    const dx = x - ship.x;
                    const dy = y - ship.y;
                    if (Math.sqrt(dx*dx + dy*dy) < 17) {
                        this.cameraFollowShip = ship;
                        this.updateSelectedDisplay();
                        break;
                    }
                }
            }
            
            setupControls() {
                document.getElementById('startBtn').addEventListener('click', () => this.startGame());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetGame());
                document.getElementById('speedBtn').addEventListener('click', () => this.toggleSpeed());
                document.getElementById('dashboardToggle').addEventListener('click', () => this.toggleDashboard());
                
                document.getElementById('controlsToggle').addEventListener('click', () => {
                    const panel = document.getElementById('controlsPanel');
                    panel.classList.toggle('hidden');
                });
                
                // Add keyboard controls for pause
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'KeyP' || e.code === 'Escape') {
                        this.togglePause();
                        e.preventDefault();
                    }
                });
                
                // Setup audio controls
                this.setupAudioControls();
                this.setupCannonSounds();
            }
            
            setupAudioControls() {
                const musicToggle = document.getElementById('musicToggle');
                const musicVolumeSlider = document.getElementById('musicVolumeSlider');
                const musicVolumeValue = document.getElementById('musicVolumeValue');
                const soundToggle = document.getElementById('soundToggle');
                const soundVolumeSlider = document.getElementById('soundVolumeSlider');
                const soundVolumeValue = document.getElementById('soundVolumeValue');

                // Initialize controls with current state
                musicToggle.textContent = this.gameState.audio.musicEnabled ? 'On' : 'Off';
                musicVolumeSlider.value = this.gameState.audio.musicVolume * 100;
                musicVolumeValue.textContent = Math.round(this.gameState.audio.musicVolume * 100) + '%';
                
                soundToggle.textContent = this.gameState.audio.soundEnabled ? 'On' : 'Off';
                soundVolumeSlider.value = this.gameState.audio.soundVolume * 100;
                soundVolumeValue.textContent = Math.round(this.gameState.audio.soundVolume * 100) + '%';

                // Music toggle
                musicToggle.addEventListener('click', () => {
                    this.gameState.audio.musicEnabled = !this.gameState.audio.musicEnabled;
                    musicToggle.textContent = this.gameState.audio.musicEnabled ? 'On' : 'Off';
                    
                    if (this.gameState.audio.musicEnabled) {
                        if (this.gameState.gameStarted && !this.gameState.gamePaused) {
                            this.playBackgroundMusic();
                        }
                    } else {
                        this.pauseBackgroundMusic();
                    }
                });

                // Music volume slider
                musicVolumeSlider.addEventListener('input', (e) => {
                    const volume = parseInt(e.target.value) / 100;
                    this.gameState.audio.musicVolume = volume;
                    musicVolumeValue.textContent = e.target.value + '%';
                    
                    if (this.backgroundMusic) {
                        this.backgroundMusic.volume = volume;
                    }
                });

                // Sound effects toggle
                soundToggle.addEventListener('click', () => {
                    this.gameState.audio.soundEnabled = !this.gameState.audio.soundEnabled;
                    soundToggle.textContent = this.gameState.audio.soundEnabled ? 'On' : 'Off';
                });

                // Sound effects volume slider
                soundVolumeSlider.addEventListener('input', (e) => {
                    const volume = parseInt(e.target.value) / 100;
                    this.gameState.audio.soundVolume = volume;
                    soundVolumeValue.textContent = e.target.value + '%';
                    this.updateCannonSoundVolumes();
                });
                
                // Test audio button
                const testAudioBtn = document.getElementById('testAudioBtn');
                if (testAudioBtn) {
                    testAudioBtn.addEventListener('click', () => {
                        this.playRandomCannonSound();
                    });
                }
            }

            playBackgroundMusic() {
                if (this.backgroundMusic && this.gameState.audio.musicEnabled) {
                    this.backgroundMusic.volume = this.gameState.audio.musicVolume;
                    this.backgroundMusic.play().then(() => {
                        console.log('Background music started successfully');
                        this.gameState.audio.musicStarted = true;
                    }).catch(error => {
                        console.log('Background music play failed:', error);
                        // Retry once after user interaction
                        if (!this.gameState.audio.musicStarted) {
                            console.log('Retrying audio playback...');
                            setTimeout(() => {
                                this.backgroundMusic.play().catch(e => {
                                    console.log('Audio retry also failed:', e);
                                });
                            }, 1000);
                        }
                    });
                }
            }

            pauseBackgroundMusic() {
                if (this.backgroundMusic) {
                    this.backgroundMusic.pause();
                }
            }
            
            setupCannonSounds() {
                // Store cannon sound elements in the game state
                this.gameState.audio.cannonSounds = [
                    this.cannonSound1,
                    this.cannonSound2,
                    this.cannonSound3,
                    this.cannonSound5
                ];
                
                // Set initial volume for all cannon sounds
                this.updateCannonSoundVolumes();
            }
            
            updateCannonSoundVolumes() {
                const volume = this.gameState.audio.soundVolume;
                for (let sound of this.gameState.audio.cannonSounds) {
                    if (sound) {
                        sound.volume = volume;
                    }
                }
            }

            playRandomCannonSound() {
                if (!this.gameState.audio.soundEnabled || this.gameState.audio.cannonSounds.length === 0) {
                    return;
                }

                // Pick a random cannon sound
                const randomIndex = Math.floor(Math.random() * this.gameState.audio.cannonSounds.length);
                const sound = this.gameState.audio.cannonSounds[randomIndex];
                
                if (sound) {
                    // Reset the sound to the beginning and play
                    sound.currentTime = 0;
                    sound.play().catch(error => {
                        console.log('Cannon sound play failed:', error);
                    });
                }
            }
            
            updateSelectedDisplay() {
                // Update blue team display
                if (this.blueSelectedShip) {
                    document.getElementById('blueShipInfo').textContent = 
                        `Ship ${this.blueSelectedShip.shipNumber || '?'} - ${Math.round(this.blueSelectedShip.health)}HP`;
                } else {
                    document.getElementById('blueShipInfo').textContent = 'No ship selected';
                }
                
                // Update red team display  
                if (this.redSelectedShip) {
                    document.getElementById('redShipInfo').textContent = 
                        `Ship ${this.redSelectedShip.shipNumber || '?'} - ${Math.round(this.redSelectedShip.health)}HP`;
                } else {
                    document.getElementById('redShipInfo').textContent = 'No ship selected';
                }
            }
            
            updateAIDemoShipSelection() {
                if (!this.gameState.gameStarted || this.gameState.gamePaused) return;
                
                const currentTime = Date.now();
                const blueShips = this.gameState.ships.filter(s => s.playerId === 'blue' && s.health > 0);
                const redShips = this.gameState.ships.filter(s => s.playerId === 'red' && s.health > 0);
                
                // Update blue team selection
                if (currentTime - this.lastBlueSwitchTime > this.autoSwitchInterval || 
                    !this.blueSelectedShip || 
                    this.blueSelectedShip.health <= 0) {
                    
                    if (blueShips.length > 0) {
                        blueShips.sort((a, b) => (a.shipNumber || 0) - (b.shipNumber || 0));
                        this.blueShipIndex = (this.blueShipIndex + 1) % blueShips.length;
                        this.blueSelectedShip = blueShips[this.blueShipIndex];
                        this.lastBlueSwitchTime = currentTime;
                    } else {
                        this.blueSelectedShip = null;
                    }
                }
                
                // Update red team selection
                if (currentTime - this.lastRedSwitchTime > this.autoSwitchInterval + 2500 || // Offset timing
                    !this.redSelectedShip || 
                    this.redSelectedShip.health <= 0) {
                    
                    if (redShips.length > 0) {
                        redShips.sort((a, b) => (a.shipNumber || 0) - (b.shipNumber || 0));
                        this.redShipIndex = (this.redShipIndex + 1) % redShips.length;
                        this.redSelectedShip = redShips[this.redShipIndex];
                        this.lastRedSwitchTime = currentTime;
                    } else {
                        this.redSelectedShip = null;
                    }
                }
                
                // Camera follows whichever ship was selected most recently
                if (this.lastBlueSwitchTime > this.lastRedSwitchTime && this.blueSelectedShip) {
                    this.cameraFollowShip = this.blueSelectedShip;
                } else if (this.redSelectedShip) {
                    this.cameraFollowShip = this.redSelectedShip;
                }
                
                this.updateSelectedDisplay();
            }
            
            generateRandomSpawnPoints() {
                // Generate two spawn points on opposite sides of the map
                // Choose which sides randomly: corners, edges, or diagonal opposites
                const spawnType = Math.floor(Math.random() * 3);
                
                if (spawnType === 0) {
                    // Corner opposites (diagonal)
                    if (Math.random() < 0.5) {
                        // Top-left vs Bottom-right
                        this.gameState.players.blue.dock = { x: 50 + Math.random() * 100, y: 50 + Math.random() * 100, spawnAngle: -45 * Math.PI/180 };
                        this.gameState.players.red.dock = { x: 850 + Math.random() * 100, y: 550 + Math.random() * 100, spawnAngle: 135 * Math.PI/180 };
                    } else {
                        // Top-right vs Bottom-left
                        this.gameState.players.blue.dock = { x: 850 + Math.random() * 100, y: 50 + Math.random() * 100, spawnAngle: 135 * Math.PI/180 };
                        this.gameState.players.red.dock = { x: 50 + Math.random() * 100, y: 550 + Math.random() * 100, spawnAngle: -45 * Math.PI/180 };
                    }
                } else if (spawnType === 1) {
                    // Left vs Right sides
                    this.gameState.players.blue.dock = { x: 50 + Math.random() * 100, y: 150 + Math.random() * 400, spawnAngle: 0 * Math.PI/180 };
                    this.gameState.players.red.dock = { x: 850 + Math.random() * 100, y: 150 + Math.random() * 400, spawnAngle: 180 * Math.PI/180 };
                } else {
                    // Top vs Bottom sides
                    this.gameState.players.blue.dock = { x: 200 + Math.random() * 600, y: 50 + Math.random() * 100, spawnAngle: 90 * Math.PI/180 };
                    this.gameState.players.red.dock = { x: 200 + Math.random() * 600, y: 550 + Math.random() * 100, spawnAngle: -90 * Math.PI/180 };
                }
                
                console.log(`Demo - Generated spawn points: Blue (${Math.round(this.gameState.players.blue.dock.x)}, ${Math.round(this.gameState.players.blue.dock.y)}) vs Red (${Math.round(this.gameState.players.red.dock.x)}, ${Math.round(this.gameState.players.red.dock.y)})`);
            }

            generateObstacles() {
                this.gameState.obstacles = [];
                
                // Generate varied islands (static) - avoid spawning near team bases
                const numIslands = 3 + Math.floor(Math.random() * 3); // 3-5 islands
                const blueBase = this.gameState.players.blue.dock;
                const redBase = this.gameState.players.red.dock;
                const minBaseDistance = Math.min(this.canvas.width, this.canvas.height) * 0.2; // 20% of smaller dimension
                
                for (let i = 0; i < numIslands; i++) {
                    let x, y, attempts = 0;
                    
                    do {
                        x = this.canvas.width * 0.1 + Math.random() * this.canvas.width * 0.8; // 10-90% of width
                        y = this.canvas.height * 0.1 + Math.random() * this.canvas.height * 0.8; // 10-90% of height
                        attempts++;
                        
                        // Check distance from both bases
                        const distToBlue = Math.sqrt((x - blueBase.x) ** 2 + (y - blueBase.y) ** 2);
                        const distToRed = Math.sqrt((x - redBase.x) ** 2 + (y - redBase.y) ** 2);
                        
                        // Check distance from existing islands
                        let tooClose = false;
                        for (const existingIsland of this.gameState.obstacles) {
                            if (existingIsland.type === 'island') {
                                const dist = Math.sqrt((x - existingIsland.x) ** 2 + (y - existingIsland.y) ** 2);
                                if (dist < existingIsland.radius + 200) { // Minimum spacing
                                    tooClose = true;
                                    break;
                                }
                            }
                        }
                        
                        if (distToBlue >= minBaseDistance && distToRed >= minBaseDistance && !tooClose) {
                            break; // Good position found
                        }
                    } while (attempts < 30);
                    
                    // Create varied island sizes (smaller)
                    let radius, islandType;
                    const sizeRoll = Math.random();
                    if (sizeRoll < 0.3) {
                        // Small islands (30%)
                        radius = 30 + Math.random() * 20; // 30-50 radius
                        islandType = 'small';
                    } else if (sizeRoll < 0.7) {
                        // Medium islands (40%)
                        radius = 50 + Math.random() * 25; // 50-75 radius
                        islandType = 'medium';
                    } else {
                        // Large islands (30%)
                        radius = 75 + Math.random() * 35; // 75-110 radius
                        islandType = 'large';
                    }
                    
                    this.gameState.obstacles.push({
                        type: 'island',
                        x: x,
                        y: y,
                        radius: Math.round(radius),
                        destructible: false,
                        imageIndex: Math.floor(Math.random() * 6), // 0-5 for 6 island images
                        islandType: islandType
                    });
                    
                    console.log(`Generated ${islandType} island with radius ${Math.round(radius)} at (${Math.round(x)}, ${Math.round(y)})`);
                }
                
                // Generate initial icebergs with drift properties - randomized count
                const numIcebergs = 2 + Math.floor(Math.random() * 4); // 2-5 icebergs
                console.log(`Generating ${numIcebergs} icebergs`);
                
                for (let i = 0; i < numIcebergs; i++) {
                    this.createDriftingIceberg(i < Math.ceil(numIcebergs * 0.6)); // 60% spawn on screen
                }
            }
            
            createDriftingIceberg(forceOnScreen = false) {
                let x, y;
                
                if (forceOnScreen) {
                    // Force spawn on-screen in a safe location
                    let attempts = 0;
                    let validPosition = false;
                    
                    while (!validPosition && attempts < 10) {
                        x = Math.round((150 + Math.random() * 700) * SCALE_X);
                        y = Math.round((100 + Math.random() * 500) * SCALE_Y);
                        
                        // Check dock exclusion zones
                        const blueDock = this.gameState.players.blue.dock;
                        const redDock = this.gameState.players.red.dock;
                        
                        const distToBlueDock = Math.sqrt((x - blueDock.x) ** 2 + (y - blueDock.y) ** 2);
                        const distToRedDock = Math.sqrt((x - redDock.x) ** 2 + (y - redDock.y) ** 2);
                        
                        // Check distance from islands
                        let tooCloseToIsland = false;
                        for (let obstacle of this.gameState.obstacles) {
                            if (obstacle.type === 'island') {
                                const distToIsland = Math.sqrt((x - obstacle.x) ** 2 + (y - obstacle.y) ** 2);
                                if (distToIsland < obstacle.radius + 50) {
                                    tooCloseToIsland = true;
                                    break;
                                }
                            }
                        }
                        
                        if (distToBlueDock >= 80 && distToRedDock >= 80 && !tooCloseToIsland) {
                            validPosition = true;
                        }
                        attempts++;
                    }
                    
                    if (!validPosition) {
                        forceOnScreen = false;
                    }
                }
                
                if (!forceOnScreen) {
                    // Random spawn position (can be off-screen)
                    const spawnSide = Math.floor(Math.random() * 4);
                    
                    switch (spawnSide) {
                        case 0: // Top
                            x = Math.random() * this.canvas.width;
                            y = -50;
                            break;
                        case 1: // Right
                            x = this.canvas.width + 50;
                            y = Math.random() * this.canvas.height;
                            break;
                        case 2: // Bottom
                            x = Math.random() * this.canvas.width;
                            y = this.canvas.height + 50;
                            break;
                        case 3: // Left
                            x = -50;
                            y = Math.random() * this.canvas.height;
                            break;
                    }
                }
                
                // Create varied iceberg sizes
                let radius, icebergType, driftSpeed;
                const sizeRoll = Math.random();
                if (sizeRoll < 0.4) {
                    // Small icebergs (40%) - faster
                    radius = 25 + Math.random() * 20; // 25-45 radius
                    icebergType = 'small';
                    driftSpeed = 4 + Math.random() * 3; // 4-7 speed
                } else if (sizeRoll < 0.8) {
                    // Medium icebergs (40%) - moderate
                    radius = 45 + Math.random() * 25; // 45-70 radius  
                    icebergType = 'medium';
                    driftSpeed = 2.5 + Math.random() * 2.5; // 2.5-5 speed
                } else {
                    // Large icebergs (20%) - slower
                    radius = 70 + Math.random() * 40; // 70-110 radius
                    icebergType = 'large';
                    driftSpeed = 1 + Math.random() * 2; // 1-3 speed
                }

                const iceberg = {
                    type: 'iceberg',
                    x: x,
                    y: y,
                    radius: Math.round(radius),
                    destructible: true,
                    imageIndex: Math.floor(Math.random() * 12), // 0-11 for 12 iceberg images
                    driftAngle: Math.random() * Math.PI * 2,
                    driftSpeed: driftSpeed,
                    lastPositionUpdate: Date.now(),
                    icebergType: icebergType
                };
                
                console.log(`Generated ${icebergType} iceberg with radius ${Math.round(radius)} and speed ${driftSpeed.toFixed(1)}`);
                
                this.gameState.obstacles.push(iceberg);
            }
            
            scheduleInitialShipSpawning() {
                this.clearAllSpawnTimeouts();
                
                // Schedule all 5 ships to spawn for each team
                for (let i = 0; i < 5; i++) {
                    const timeoutId = setTimeout(() => {
                        if (this.gameState.gameStarted && !this.gameState.gamePaused) {
                            this.spawnShip('blue');
                            this.spawnShip('red');
                        }
                        
                        const index = this.spawnTimeouts.indexOf(timeoutId);
                        if (index > -1) {
                            this.spawnTimeouts.splice(index, 1);
                        }
                    }, i * 3000);
                    
                    this.spawnTimeouts.push(timeoutId);
                }
            }
            
            clearAllSpawnTimeouts() {
                for (let timeoutId of this.spawnTimeouts) {
                    clearTimeout(timeoutId);
                }
                this.spawnTimeouts = [];
            }
            
            startGame() {
                this.gameState.gameStarted = true;
                this.gameState.gamePaused = false;
                this.gameState.countdownActive = true;
                this.gameState.countdown = 3;
                this.gameState.gameStartTime = Date.now();
                this.gameState.totalPausedTime = 0;
                this.blueAISelectedShipIndex = 0;
                this.redAISelectedShipIndex = 0;
                this.lastIcebergSpawn = Date.now();
                this.lastNeutralSpawn = Date.now(); // Initialize neutral ship spawning
                
                // Try to start background music immediately on user click
                this.playBackgroundMusic();
                
                this.showCountdown();
            }
            
            showCountdown() {
                if (this.gameState.countdown > 0) {
                    const titleElement = document.getElementById('menuTitle');
                    titleElement.textContent = this.gameState.countdown;
                    titleElement.className = 'countdown';
                    document.getElementById('menuContent').innerHTML = '';
                    document.getElementById('gameMenu').classList.remove('hidden');
                    
                    this.gameState.countdown--;
                    
                    setTimeout(() => {
                        this.showCountdown();
                    }, 1000);
                } else {
                    this.gameState.countdownActive = false;
                    document.getElementById('gameMenu').classList.add('hidden');
                    
                    const titleElement = document.getElementById('menuTitle');
                    titleElement.className = '';
                    
                    // Start background music right when gameplay begins
                    this.playBackgroundMusic();
                    
                    this.scheduleInitialShipSpawning();
                    
                    // Initialize AI demo ship selection for both teams
                    setTimeout(() => {
                        this.updateAIDemoShipSelection();
                    }, 1000);
                }
            }
            
            togglePause() {
                if (!this.gameState.gameStarted || this.gameState.countdownActive) return;
                
                this.gameState.gamePaused = !this.gameState.gamePaused;
                
                if (this.gameState.gamePaused) {
                    this.gameState.pauseStartTime = Date.now();
                    
                    // Pause background music
                    this.pauseBackgroundMusic();
                    
                    document.getElementById('menuTitle').textContent = 'Game Paused';
                    document.getElementById('menuContent').innerHTML = `
                        <button id="resumeBtn">Resume Game</button>
                        <button id="restartBtn">Restart Game</button>
                        <button id="mainMenuBtn">Return to Main Menu</button>
                    `;
                    
                    // Add event listeners after creating the buttons
                    setTimeout(() => {
                        document.getElementById('resumeBtn')?.addEventListener('click', () => this.togglePause());
                        document.getElementById('restartBtn')?.addEventListener('click', () => this.restartGame());
                        document.getElementById('mainMenuBtn')?.addEventListener('click', () => this.returnToMainMenu());
                    }, 0);
                    
                    document.getElementById('gameMenu').classList.remove('hidden');
                } else {
                    if (this.gameState.pauseStartTime) {
                        this.gameState.totalPausedTime += Date.now() - this.gameState.pauseStartTime;
                        this.gameState.pauseStartTime = null;
                    }
                    
                    // Resume background music
                    this.playBackgroundMusic();
                    
                    document.getElementById('gameMenu').classList.add('hidden');
                }
            }
            
            restartGame() {
                this.resetGame();
                this.startGame();
            }
            
            returnToMainMenu() {
                // Navigate back to the main game selection menu
                window.location.href = 'index.html';
            }
            
            spawnShip(playerId) {
                const dock = this.gameState.players[playerId].dock;
                const currentTime = Date.now();
                
                let shipNumber = null;
                const existingNumbers = this.gameState.ships
                    .filter(s => s.playerId === playerId)
                    .map(s => s.shipNumber)
                    .filter(n => n !== undefined);
                
                for (let i = 1; i <= 5; i++) {
                    if (!existingNumbers.includes(i)) {
                        shipNumber = i;
                        break;
                    }
                }
                
                const ship = {
                    id: Math.random().toString(36).substr(2, 9),
                    playerId: playerId,
                    shipNumber: shipNumber,
                    x: dock.x + (Math.random() - 0.5) * 60,
                    y: dock.y + (Math.random() - 0.5) * 60,
                    angle: dock.spawnAngle,
                    rudderAngle: 0,
                    targetRudderAngle: 0,
                    cannonAngle: dock.spawnAngle,
                    speed: 25,
                    targetSpeed: 25,
                    defaultSpeed: 25,
                    health: 3,
                    maxHealth: 3,
                    lastShot: currentTime,
                    shotCooldown: 5000,
                    spawnTime: currentTime,
                    lastRamTime: 0,
                    aiTarget: null,
                    aiLastDecision: 0,
                    aiDecisionCooldown: 1000,
                    aiState: 'patrol',
                    aiType: this.gameState.players[playerId].aiType,
                    upgrades: { health: 0, damage: 0, rateOfFire: 0, speed: 0 },
                    killTierProgress: 0,
                    tier: 1
                };
                
                this.gameState.ships.push(ship);
                this.gameState.players[playerId].shipCount++;
                return ship;
            }
            
            spawnNeutralShip() {
                if (!this.gameState.gameStarted || this.gameState.gamePaused) return;
                
                // Initialize neutralShips array if it doesn't exist
                if (!this.gameState.neutralShips) {
                    this.gameState.neutralShips = [];
                }
                
                // Limit to maximum 2 neutral ships
                if (this.gameState.neutralShips.length >= 2) {
                    return;
                }
                
                const currentTime = Date.now();
                if (currentTime - this.lastNeutralSpawn < GAME_CONFIG.NEUTRAL_SHIP_SPAWN_INTERVAL) {
                    return; // No console spam
                }
                
                if (Math.random() > GAME_CONFIG.NEUTRAL_SHIP_SPAWN_CHANCE) {
                    this.lastNeutralSpawn = currentTime; // Reset timer even if chance fails
                    return;
                }
                
                // Spawn near a random island
                const islands = this.gameState.obstacles.filter(obs => obs.type === 'island');
                if (islands.length === 0) return; // No islands to spawn from
                
                const randomIsland = islands[Math.floor(Math.random() * islands.length)];
                
                // Spawn at a random angle around the island, outside its radius
                const spawnAngle = Math.random() * Math.PI * 2;
                const spawnDistance = randomIsland.radius + 40 + Math.random() * 20; // 40-60 pixels from island edge
                
                const x = randomIsland.x + Math.cos(spawnAngle) * spawnDistance;
                const y = randomIsland.y + Math.sin(spawnAngle) * spawnDistance;
                
                // Point toward the center of the map for initial direction
                const centerX = 400;
                const centerY = 350;
                const angle = Math.atan2(centerY - y, centerX - x);
                
                const neutralShip = {
                    id: Math.random().toString(36).substr(2, 9),
                    shipNumber: this.gameState.neutralShips.length + 1, // Give them numbers
                    x: x,
                    y: y,
                    angle: angle,
                    speed: GAME_CONFIG.NEUTRAL_SHIP_SPEED,
                    health: GAME_CONFIG.NEUTRAL_SHIP_MAX_HEALTH,
                    maxHealth: GAME_CONFIG.NEUTRAL_SHIP_MAX_HEALTH,
                    lastShot: currentTime,
                    shotCooldown: 8000, // Much slower firing - every 8 seconds
                    aiTarget: null,
                    timeInCombat: 0,
                    spawnTime: currentTime,
                    upgrades: { health: 0, damage: 0, rateOfFire: 0, speed: 0 },
                    killTierProgress: 0,
                    tier: 1
                };
                
                this.gameState.neutralShips.push(neutralShip);
                this.lastNeutralSpawn = currentTime;
            }
            
            updateNeutralShips(deltaTime) {
                if (!this.gameState.neutralShips) {
                    this.gameState.neutralShips = [];
                }
                
                for (let neutralShip of this.gameState.neutralShips) {
                    this.executeNeutralShipAI(neutralShip, deltaTime);
                    
                    // Update position with proper delta time scaling (match regular ships)
                    const deltaX = Math.cos(neutralShip.angle) * neutralShip.speed * deltaTime * 0.001;
                    const deltaY = Math.sin(neutralShip.angle) * neutralShip.speed * deltaTime * 0.001;
                    
                    // Safety check for NaN values
                    if (isNaN(deltaX) || isNaN(deltaY) || isNaN(neutralShip.x) || isNaN(neutralShip.y)) {
                        // Reset to valid position near center of map
                        neutralShip.x = 400 + (Math.random() - 0.5) * 100;
                        neutralShip.y = 300 + (Math.random() - 0.5) * 100;
                        neutralShip.angle = Math.random() * Math.PI * 2;
                        neutralShip.speed = GAME_CONFIG.NEUTRAL_SHIP_SPEED;
                        return;
                    }
                    
                    neutralShip.x += deltaX;
                    neutralShip.y += deltaY;
                    
                    // Obstacle collision detection and avoidance
                    for (let obstacle of this.gameState.obstacles) {
                        const dx = neutralShip.x - obstacle.x;
                        const dy = neutralShip.y - obstacle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minDistance = obstacle.radius + GAME_CONFIG.SHIP_RADIUS + 5; // Buffer zone
                        
                        if (distance < minDistance) {
                            // Push ship away from obstacle
                            const pushStrength = (minDistance - distance) / minDistance;
                            const pushX = (dx / distance) * pushStrength * 3;
                            const pushY = (dy / distance) * pushStrength * 3;
                            
                            neutralShip.x += pushX;
                            neutralShip.y += pushY;
                            
                            // Deflect movement angle to go around obstacle
                            const obstacleAngle = Math.atan2(dy, dx);
                            const deflectionAngle = obstacleAngle + (Math.PI / 2) * (Math.random() > 0.5 ? 1 : -1);
                            neutralShip.angle = deflectionAngle;
                            
                            // Slow down when navigating around obstacles
                            neutralShip.speed = GAME_CONFIG.NEUTRAL_SHIP_SPEED * 0.5;
                        }
                    }
                    
                    // Keep ships within screen boundaries
                    const mapBounds = {
                        left: 0,
                        right: GAME_CONFIG.MAP_WIDTH,
                        top: 0,
                        bottom: GAME_CONFIG.MAP_HEIGHT
                    };
                    
                    if (neutralShip.x < mapBounds.left || neutralShip.x > mapBounds.right) {
                        neutralShip.angle = Math.PI - neutralShip.angle;
                        neutralShip.x = Math.max(mapBounds.left, Math.min(mapBounds.right, neutralShip.x));
                    }
                    if (neutralShip.y < mapBounds.top || neutralShip.y > mapBounds.bottom) {
                        neutralShip.angle = -neutralShip.angle;
                        neutralShip.y = Math.max(mapBounds.top, Math.min(mapBounds.bottom, neutralShip.y));
                    }
                    
                    // Auto-fire at nearby enemy ships
                    const currentTime = Date.now();
                    if (currentTime - neutralShip.lastShot >= neutralShip.shotCooldown) {
                        if (neutralShip.aiTarget) {
                            this.fireNeutralCannonball(neutralShip);
                            neutralShip.lastShot = currentTime;
                        }
                    }
                }
            }
            
            executeNeutralShipAI(neutralShip, deltaTime) {
                // Pirate AI: Find closest ship and circle around it at optimal combat range
                let closestShip = null;
                let closestDistance = Infinity;
                
                for (let ship of this.gameState.ships) {
                    const dx = neutralShip.x - ship.x;
                    const dy = neutralShip.y - ship.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestShip = ship;
                    }
                }
                
                neutralShip.aiTarget = closestShip;
                
                if (closestShip) {
                    const dx = closestShip.x - neutralShip.x;
                    const dy = closestShip.y - neutralShip.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const angleToTarget = Math.atan2(dy, dx);
                    
                    // Optimal combat range for circling
                    const optimalRange = 120;
                    const tooClose = 80;
                    const tooFar = 200;
                    
                    if (distance < tooClose) {
                        // Too close - retreat while keeping target in sight
                        const retreatAngle = angleToTarget + Math.PI; // Opposite direction
                        neutralShip.angle = retreatAngle;
                        neutralShip.speed = GAME_CONFIG.NEUTRAL_SHIP_SPEED * 0.8;
                    } else if (distance > tooFar) {
                        // Too far - approach target
                        neutralShip.angle = angleToTarget;
                        neutralShip.speed = GAME_CONFIG.NEUTRAL_SHIP_SPEED;
                    } else {
                        // Optimal range - circle strafe like a pirate
                        const circleDirection = neutralShip.circleDirection || (Math.random() > 0.5 ? 1 : -1);
                        neutralShip.circleDirection = circleDirection; // Remember direction
                        
                        // Circle around target (perpendicular to target direction)
                        const circleAngle = angleToTarget + (Math.PI / 2) * circleDirection;
                        neutralShip.angle = circleAngle;
                        neutralShip.speed = GAME_CONFIG.NEUTRAL_SHIP_SPEED * 0.7; // Slower when circling
                        
                        // Occasionally change circle direction for unpredictability (less frequent)
                        if (!neutralShip.lastDirectionChange) neutralShip.lastDirectionChange = 0;
                        if (Date.now() - neutralShip.lastDirectionChange > 3000 && Math.random() < 0.001) {
                            neutralShip.circleDirection *= -1;
                            neutralShip.lastDirectionChange = Date.now();
                        }
                    }
                }
            }
            
            fireNeutralCannonball(neutralShip) {
                if (!neutralShip.aiTarget) return;
                
                const dx = neutralShip.aiTarget.x - neutralShip.x;
                const dy = neutralShip.aiTarget.y - neutralShip.y;
                const aimAngle = Math.atan2(dy, dx);
                
                const cannonball = {
                    id: Math.random().toString(36).substr(2, 9),
                    x: neutralShip.x + Math.cos(aimAngle) * 15,
                    y: neutralShip.y + Math.sin(aimAngle) * 15,
                    angle: aimAngle,
                    speed: GAME_CONFIG.CANNONBALL_SPEED,
                    shooterId: neutralShip.id,
                    shooterPlayerId: 'neutral', // Fix crash - set proper playerId
                    shooterType: 'neutral',
                    dead: false
                };
                
                this.gameState.cannonballs.push(cannonball);
                this.playRandomCannonSound();
            }
            
            calculateShipTier(ship) {
                if (!ship.upgrades) return 1;
                const totalUpgrades = ship.upgrades.health + ship.upgrades.damage + 
                                    ship.upgrades.rateOfFire + ship.upgrades.speed;
                // Include kill progress in tier calculation
                const killProgress = (ship.killTierProgress || 0);
                const totalProgress = totalUpgrades + killProgress;
                return Math.min(Math.floor(totalProgress / 2) + 1, GAME_CONFIG.MAX_SHIP_TIER);
            }

            awardKillTierProgression(killerShipId, killedShip) {
                // Find the killer ship
                const killerShip = this.gameState.ships.find(s => s.id === killerShipId);
                if (!killerShip) return;
                
                // Initialize kill progress if it doesn't exist
                if (!killerShip.killTierProgress) {
                    killerShip.killTierProgress = 0;
                }
                
                // Award 0.5 tier progress for each kill (2 kills = 1 tier level)
                killerShip.killTierProgress += 0.5;
                
                // Update ship tier
                killerShip.tier = this.calculateShipTier(killerShip);
                
                console.log(`Ship ${killerShip.id} got a kill! Kill progress: ${killerShip.killTierProgress}, New tier: ${killerShip.tier}`);
            }
            
            dropPowerUp(x, y) {
                // Initialize powerUps array if it doesn't exist
                if (!this.gameState.powerUps) {
                    this.gameState.powerUps = [];
                }
                
                const powerUpTypes = ['health', 'damage', 'rateOfFire', 'speed'];
                const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                
                const powerUp = {
                    id: Math.random().toString(36).substr(2, 9),
                    type: type,
                    x: x,
                    y: y,
                    spawnTime: Date.now(),
                    collected: false
                };
                
                this.gameState.powerUps.push(powerUp);
            }
            
            applyPowerUp(ship, powerUp) {
                if (!ship.upgrades) {
                    ship.upgrades = { health: 0, damage: 0, rateOfFire: 0, speed: 0 };
                }
                
                ship.upgrades[powerUp.type]++;
                
                // Apply immediate effects
                switch (powerUp.type) {
                    case 'health':
                        ship.health = Math.min(ship.health + GAME_CONFIG.UPGRADE_HEALTH_BONUS, 
                                             ship.maxHealth + ship.upgrades.health);
                        ship.maxHealth = 3 + ship.upgrades.health;
                        break;
                    case 'damage':
                        // Damage is applied when firing
                        break;
                    case 'rateOfFire':
                        ship.shotCooldown = Math.max(2000, 5000 * Math.pow(GAME_CONFIG.UPGRADE_RATE_OF_FIRE_BONUS, ship.upgrades.rateOfFire));
                        break;
                    case 'speed':
                        ship.defaultSpeed = 25 * Math.pow(GAME_CONFIG.UPGRADE_SPEED_MULTIPLIER, ship.upgrades.speed);
                        ship.targetSpeed = ship.defaultSpeed;
                        break;
                }
                
                // Update tier
                ship.tier = this.calculateShipTier(ship);
            }
            
            updatePowerUps() {
                if (!this.gameState.powerUps) {
                    this.gameState.powerUps = [];
                    return;
                }
                
                const currentTime = Date.now();
                
                // Remove expired power-ups (last 30 seconds)
                this.gameState.powerUps = this.gameState.powerUps.filter(powerUp => 
                    currentTime - powerUp.spawnTime < 30000 && !powerUp.collected
                );
            }
            
            updateAI(deltaTime) {
                const currentTime = Date.now();
                const blueShips = this.gameState.ships.filter(s => s.playerId === 'blue');
                const redShips = this.gameState.ships.filter(s => s.playerId === 'red');
                
                // Update blue AI
                if (currentTime - this.blueAILastShipSwitch > (1500 + Math.random() * 1500)) {
                    if (blueShips.length > 0) {
                        this.blueAISelectedShipIndex = Math.floor(Math.random() * blueShips.length);
                        this.blueAILastShipSwitch = currentTime;
                    }
                }
                
                if (blueShips.length > 0 && this.blueAISelectedShipIndex < blueShips.length) {
                    const selectedBlueShip = blueShips[this.blueAISelectedShipIndex];
                    
                    if (currentTime - selectedBlueShip.aiLastDecision > selectedBlueShip.aiDecisionCooldown) {
                        this.makeAIDecision(selectedBlueShip, 'red');
                        selectedBlueShip.aiLastDecision = currentTime;
                    }
                    
                    this.executeAIBehavior(selectedBlueShip);
                }
                
                // Update red AI
                if (currentTime - this.redAILastShipSwitch > (2000 + Math.random() * 2000)) {
                    if (redShips.length > 0) {
                        this.redAISelectedShipIndex = Math.floor(Math.random() * redShips.length);
                        this.redAILastShipSwitch = currentTime;
                    }
                }
                
                if (redShips.length > 0 && this.redAISelectedShipIndex < redShips.length) {
                    const selectedRedShip = redShips[this.redAISelectedShipIndex];
                    
                    if (currentTime - selectedRedShip.aiLastDecision > selectedRedShip.aiDecisionCooldown) {
                        this.makeAIDecision(selectedRedShip, 'blue');
                        selectedRedShip.aiLastDecision = currentTime;
                    }
                    
                    this.executeAIBehavior(selectedRedShip);
                }
            }
            
            makeAIDecision(ship, enemyTeam) {
                const enemyShips = this.gameState.ships.filter(s => s.playerId === enemyTeam);
                const neutralShips = this.gameState.neutralShips || [];
                const powerUps = this.gameState.powerUps || [];
                
                // Get difficulty settings for this ship's team
                const difficulty = GAME_CONFIG.AI_DIFFICULTY[this.gameState.players[ship.playerId].difficulty];
                
                // First check for power-ups based on difficulty
                if (powerUps.length > 0 && Math.random() < difficulty.powerUpAwareness) {
                    let closestPowerUp = null;
                    let closestPUDistance = Infinity;
                    
                    for (let powerUp of powerUps) {
                        if (powerUp.collected) continue;
                        const dx = ship.x - powerUp.x;
                        const dy = ship.y - powerUp.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < closestPUDistance && distance < Math.round(150 * SCALE_AVG)) { // Only consider nearby power-ups (scaled)
                            closestPUDistance = distance;
                            closestPowerUp = powerUp;
                        }
                    }
                    
                    if (closestPowerUp) {
                        ship.aiTarget = closestPowerUp;
                        ship.aiTargetType = 'powerup';
                        ship.aiState = 'seekPowerUp';
                        return;
                    }
                }
                
                // Check for neutral ships as priority targets (they drop power-ups!) - but use strategic thinking
                if (neutralShips.length > 0 && Math.random() < difficulty.neutralShipPriority) {
                    let closestNeutral = null;
                    let closestNeutralDistance = Infinity;
                    
                    for (let neutralShip of neutralShips) {
                        const dx = ship.x - neutralShip.x;
                        const dy = ship.y - neutralShip.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        // Strategic range varies by difficulty
                        const maxRange = 150 + difficulty.strategicThinking * 100; // 150-250 range
                        if (distance < closestNeutralDistance && distance < maxRange) {
                            closestNeutralDistance = distance;
                            closestNeutral = neutralShip;
                        }
                    }
                    
                    if (closestNeutral) {
                        ship.aiTarget = closestNeutral;
                        ship.aiTargetType = 'neutral';
                        ship.aiState = 'attack';
                        return;
                    }
                }
                
                // Default to enemy ships
                if (enemyShips.length === 0) return;
                
                let closestShip = null;
                let closestDistance = Infinity;
                
                for (let enemyShip of enemyShips) {
                    const dx = ship.x - enemyShip.x;
                    const dy = ship.y - enemyShip.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestShip = enemyShip;
                    }
                }
                
                ship.aiTarget = closestShip;
                ship.aiTargetType = 'enemy';
                
                // Apply difficulty-based aggression and reaction time
                const aggressionRange = 200 * difficulty.aggressionLevel;
                ship.aiDecisionCooldown = difficulty.reactionTime + Math.random() * 300;
                
                // Different AI types have different engagement ranges
                if (ship.aiType === 'aggressive') {
                    if (closestDistance < aggressionRange) {
                        ship.aiState = 'attack';
                    } else {
                        ship.aiState = 'patrol';
                    }
                } else if (ship.aiType === 'defensive') {
                    if (closestDistance < aggressionRange * 0.75) {
                        ship.aiState = ship.health <= 1 ? 'evade' : 'attack';
                    } else {
                        ship.aiState = 'patrol';
                    }
                } else { // balanced
                    if (closestDistance < aggressionRange * 0.875) { // 87.5% - middle ground
                        ship.aiState = ship.health <= 1 ? 'evade' : 'attack';
                    } else {
                        ship.aiState = 'patrol';
                    }
                }
            }
            
            executeAIBehavior(ship) {
                if (!ship.aiTarget) return;
                
                const dx = ship.aiTarget.x - ship.x;
                const dy = ship.aiTarget.y - ship.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                const angleToTarget = Math.atan2(dy, dx);
                
                // Handle power-up seeking behavior
                if (ship.aiTargetType === 'powerup') {
                    // Simple movement towards power-up
                    ship.cannonAngle = angleToTarget; // Aim forward
                    ship.targetSpeed = ship.defaultSpeed;
                    const angleDiff = this.normalizeAngle(angleToTarget - ship.angle);
                    ship.targetRudderAngle = Math.sign(angleDiff) * Math.min(Math.abs(angleDiff) * 0.6, Math.PI/6);
                    return;
                }
                
                // Calculate target's velocity for predictive aiming (only for moving targets)
                let predictedAngle = angleToTarget;
                if (ship.aiTarget.angle !== undefined && ship.aiTarget.speed !== undefined) {
                    const targetVelX = Math.cos(ship.aiTarget.angle) * ship.aiTarget.speed;
                    const targetVelY = Math.sin(ship.aiTarget.angle) * ship.aiTarget.speed;
                    
                    // Predict where target will be (lead the target)
                    const cannonballSpeed = 80;
                    const timeToImpact = distance / cannonballSpeed;
                    const predictedX = ship.aiTarget.x + targetVelX * timeToImpact * 0.05;
                    const predictedY = ship.aiTarget.y + targetVelY * timeToImpact * 0.05;
                    predictedAngle = Math.atan2(predictedY - ship.y, predictedX - ship.x);
                }
                
                switch (ship.aiState) {
                    case 'seekPowerUp':
                        // Move directly toward power-up
                        ship.cannonAngle = angleToTarget;
                        ship.targetSpeed = ship.defaultSpeed;
                        const powerUpAngleDiff = this.normalizeAngle(angleToTarget - ship.angle);
                        ship.targetRudderAngle = Math.sign(powerUpAngleDiff) * Math.min(Math.abs(powerUpAngleDiff) * 0.6, Math.PI/6);
                        break;
                    case 'attack':
                        // Use predictive aiming
                        ship.cannonAngle = predictedAngle;
                        
                        // Optimal combat distance is 100-200 pixels
                        if (distance < 100) {
                            // Too close, back off while maintaining fire angle
                            ship.targetSpeed = ship.defaultSpeed * 0.6;
                            const retreatAngle = angleToTarget + Math.PI;
                            const retreatDiff = this.normalizeAngle(retreatAngle - ship.angle);
                            ship.targetRudderAngle = Math.sign(retreatDiff) * Math.min(Math.abs(retreatDiff) * 0.4, Math.PI/6);
                        } else if (distance > 200) {
                            // Chase target
                            ship.targetSpeed = ship.defaultSpeed;
                            const angleDiff = this.normalizeAngle(angleToTarget - ship.angle);
                            ship.targetRudderAngle = Math.sign(angleDiff) * Math.min(Math.abs(angleDiff) * 0.5, Math.PI/6);
                        } else {
                            // Optimal range - circle strafe
                            ship.targetSpeed = ship.defaultSpeed * 0.8;
                            const strafeAngle = angleToTarget + Math.PI/2;
                            const strafeDiff = this.normalizeAngle(strafeAngle - ship.angle);
                            ship.targetRudderAngle = Math.sign(strafeDiff) * Math.min(Math.abs(strafeDiff) * 0.4, Math.PI/6);
                        }
                        break;
                        
                    case 'evade':
                        // Still aim at target for opportunistic shots
                        ship.cannonAngle = predictedAngle;
                        ship.targetSpeed = ship.defaultSpeed;
                        
                        // Zigzag evasion pattern
                        const evadeTime = Date.now() / 1000;
                        const zigzagOffset = Math.sin(evadeTime * 2) * Math.PI/3;
                        const evadeAngle = angleToTarget + Math.PI + zigzagOffset;
                        const evadeAngleDiff = this.normalizeAngle(evadeAngle - ship.angle);
                        ship.targetRudderAngle = Math.sign(evadeAngleDiff) * Math.min(Math.abs(evadeAngleDiff) * 0.6, Math.PI/4);
                        break;
                        
                    case 'patrol':
                        ship.cannonAngle = angleToTarget;
                        ship.targetSpeed = ship.defaultSpeed * 0.7;
                        
                        // Patrol in a figure-8 pattern around the area
                        const patrolTime = Date.now() / 1000;
                        const figure8Offset = Math.sin(patrolTime * 0.5) * Math.PI/4;
                        const patrolAngle = angleToTarget + figure8Offset;
                        const patrolAngleDiff = this.normalizeAngle(patrolAngle - ship.angle);
                        ship.targetRudderAngle = Math.sign(patrolAngleDiff) * Math.min(Math.abs(patrolAngleDiff) * 0.3, Math.PI/8);
                        break;
                }
                
                this.avoidObstacles(ship);
            }
            
            avoidObstacles(ship) {
                const avoidanceRadius = 100;
                const lookAheadDistance = 60;
                let avoidanceForceX = 0;
                let avoidanceForceY = 0;
                
                // Look ahead in the direction we're moving
                const futureX = ship.x + Math.cos(ship.angle) * lookAheadDistance;
                const futureY = ship.y + Math.sin(ship.angle) * lookAheadDistance;
                
                // Check obstacles
                for (let obstacle of this.gameState.obstacles) {
                    const dx = ship.x - obstacle.x;
                    const dy = ship.y - obstacle.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // Also check future position
                    const futureDx = futureX - obstacle.x;
                    const futureDy = futureY - obstacle.y;
                    const futureDistance = Math.sqrt(futureDx*futureDx + futureDy*futureDy);
                    
                    if (distance < avoidanceRadius + obstacle.radius) {
                        // Strong avoidance for close obstacles
                        const force = Math.pow((avoidanceRadius + obstacle.radius - distance) / avoidanceRadius, 2);
                        avoidanceForceX += (dx / distance) * force * 2;
                        avoidanceForceY += (dy / distance) * force * 2;
                    }
                    
                    // Predictive avoidance
                    if (futureDistance < obstacle.radius + 30) {
                        // We're about to hit this obstacle, strong evasion needed
                        avoidanceForceX += (futureDx / futureDistance) * 3;
                        avoidanceForceY += (futureDy / futureDistance) * 3;
                    }
                }
                
                // Wall avoidance with stronger forces
                const wallBuffer = 120;
                if (ship.x < wallBuffer) {
                    avoidanceForceX += Math.pow((wallBuffer - ship.x) / wallBuffer, 2) * 2;
                }
                if (ship.x > this.canvas.width - wallBuffer) {
                    avoidanceForceX -= Math.pow((ship.x - (this.canvas.width - wallBuffer)) / wallBuffer, 2) * 2;
                }
                if (ship.y < wallBuffer) {
                    avoidanceForceY += Math.pow((wallBuffer - ship.y) / wallBuffer, 2) * 2;
                }
                if (ship.y > this.canvas.height - wallBuffer) {
                    avoidanceForceY -= Math.pow((ship.y - (this.canvas.height - wallBuffer)) / wallBuffer, 2) * 2;
                }
                
                // Apply avoidance if needed
                if (avoidanceForceX !== 0 || avoidanceForceY !== 0) {
                    const avoidanceAngle = Math.atan2(avoidanceForceY, avoidanceForceX);
                    const angleDiff = this.normalizeAngle(avoidanceAngle - ship.angle);
                    
                    // Stronger turning for obstacle avoidance, overrides other behaviors
                    const avoidanceTurn = Math.sign(angleDiff) * Math.min(Math.abs(angleDiff) * 0.8, Math.PI/4);
                    
                    // Blend with existing target rudder angle, but prioritize avoidance
                    ship.targetRudderAngle = ship.targetRudderAngle * 0.3 + avoidanceTurn * 0.7;
                    
                    // Slow down when avoiding obstacles
                    const avoidanceStrength = Math.sqrt(avoidanceForceX*avoidanceForceX + avoidanceForceY*avoidanceForceY);
                    if (avoidanceStrength > 1) {
                        ship.targetSpeed = Math.max(ship.defaultSpeed * 0.4, ship.targetSpeed * 0.7);
                    }
                }
            }
            
            normalizeAngle(angle) {
                while (angle > Math.PI) angle -= 2 * Math.PI;
                while (angle < -Math.PI) angle += 2 * Math.PI;
                return angle;
            }
            
            updateIcebergDrift(deltaTime) {
                if (!this.gameState.gameStarted || this.gameState.gamePaused) return;
                
                const currentTime = Date.now();
                
                // Update existing iceberg positions
                for (let i = this.gameState.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = this.gameState.obstacles[i];
                    
                    if (obstacle.type === 'iceberg') {
                        // Calculate drift movement
                        const driftX = Math.cos(obstacle.driftAngle) * obstacle.driftSpeed * deltaTime * 0.001;
                        const driftY = Math.sin(obstacle.driftAngle) * obstacle.driftSpeed * deltaTime * 0.001;
                        
                        const newX = obstacle.x + driftX;
                        const newY = obstacle.y + driftY;
                        
                        // Check if new position would overlap with islands
                        let canMove = true;
                        for (let otherObstacle of this.gameState.obstacles) {
                            if (otherObstacle.type === 'island' && otherObstacle !== obstacle) {
                                const dx = newX - otherObstacle.x;
                                const dy = newY - otherObstacle.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance < obstacle.radius + otherObstacle.radius + 5) {
                                    canMove = false;
                                    break;
                                }
                            }
                        }
                        
                        // Check dock exclusion zones
                        const blueDock = this.gameState.players.blue.dock;
                        const redDock = this.gameState.players.red.dock;
                        
                        const distToBlueDock = Math.sqrt((newX - blueDock.x) ** 2 + (newY - blueDock.y) ** 2);
                        const distToRedDock = Math.sqrt((newX - redDock.x) ** 2 + (newY - redDock.y) ** 2);
                        
                        if (distToBlueDock < 60 || distToRedDock < 60) {
                            canMove = false;
                        }
                        
                        if (canMove) {
                            obstacle.x = newX;
                            obstacle.y = newY;
                        }
                        
                        // Remove icebergs that have drifted too far off the map
                        const margin = 100;
                        if (obstacle.x < -margin || obstacle.x > this.canvas.width + margin || 
                            obstacle.y < -margin || obstacle.y > this.canvas.height + margin) {
                            this.gameState.obstacles.splice(i, 1);
                        }
                    }
                }
                
                // Spawn new icebergs periodically
                if (currentTime - this.lastIcebergSpawn > this.icebergSpawnCooldown) {
                    const icebergs = this.gameState.obstacles.filter(o => o.type === 'iceberg');
                    
                    // Maintain 2-10 icebergs on the map
                    if (icebergs.length < 10) {
                        // Increase spawn chance when we have fewer icebergs
                        let spawnChance = 0.3;
                        if (icebergs.length < 2) spawnChance = 1.0; // Always spawn if below minimum
                        else if (icebergs.length < 4) spawnChance = 0.6; // Higher chance when low
                        
                        if (Math.random() < spawnChance) {
                            this.createDriftingIceberg();
                            this.lastIcebergSpawn = currentTime;
                        }
                    }
                }
            }
            
            update(deltaTime) {
                if (!this.gameState.gameStarted || this.gameState.gamePaused || this.gameState.countdownActive) return;
                
                // Apply speed multiplier for development
                const adjustedDeltaTime = deltaTime * this.speedMultiplier;
                
                this.spawnNeutralShip();
                this.updateAI(adjustedDeltaTime);
                this.updateShips(adjustedDeltaTime);
                this.updateNeutralShips(adjustedDeltaTime);
                this.updateCannonballs(adjustedDeltaTime);
                this.updateIcebergDrift(adjustedDeltaTime);
                this.updatePowerUps();
                this.updateAIDemoShipSelection(); // Auto-cycle through AI ships
                this.checkCollisions();
                this.cleanupDeadObjects();
                this.handleShooting();
                this.updateGameStatus();
                this.renderHeadingDisplay();
            }
            
            updateShips(deltaTime) {
                for (let ship of this.gameState.ships) {
                    // Update speed gradually towards target
                    const speedDiff = ship.targetSpeed - ship.speed;
                    ship.speed += Math.sign(speedDiff) * Math.min(Math.abs(speedDiff), 15 * deltaTime * 0.001);
                    
                    const rudderSpeed = 2.0;
                    const rudderDiff = ship.targetRudderAngle - ship.rudderAngle;
                    ship.rudderAngle += Math.sign(rudderDiff) * Math.min(Math.abs(rudderDiff), rudderSpeed * deltaTime * 0.001);
                    
                    // Scale turn rate with current speed - ships turn slower when moving slower
                    const speedRatio = ship.speed / ship.defaultSpeed;
                    const baseTurnRate = 0.8;
                    const minTurnRate = 0.1; // Minimum turn rate even when stopped
                    const turnRate = minTurnRate + (baseTurnRate - minTurnRate) * speedRatio;
                    ship.angle += ship.rudderAngle * turnRate * deltaTime * 0.001;
                    
                    ship.x += Math.cos(ship.angle) * ship.speed * deltaTime * 0.001;
                    ship.y += Math.sin(ship.angle) * ship.speed * deltaTime * 0.001;
                    
                    // Check boundaries with ricochet physics
                    let bounced = false;
                    
                    if (ship.x < 0) {
                        ship.x = 0;
                        ship.angle = Math.PI - ship.angle;
                        bounced = true;
                    } else if (ship.x > this.canvas.width) {
                        ship.x = this.canvas.width;
                        ship.angle = Math.PI - ship.angle;
                        bounced = true;
                    }
                    
                    if (ship.y < 0) {
                        ship.y = 0;
                        ship.angle = -ship.angle;
                        bounced = true;
                    } else if (ship.y > this.canvas.height) {
                        ship.y = this.canvas.height;
                        ship.angle = -ship.angle;
                        bounced = true;
                    }
                    
                    if (bounced) {
                        while (ship.angle > Math.PI) ship.angle -= 2 * Math.PI;
                        while (ship.angle < -Math.PI) ship.angle += 2 * Math.PI;
                        
                        ship.rudderAngle = 0;
                        ship.targetRudderAngle = 0;
                    }
                }
            }
            
            updateCannonballs(deltaTime) {
                for (let cannonball of this.gameState.cannonballs) {
                    cannonball.x += Math.cos(cannonball.angle) * cannonball.speed * deltaTime * 0.001;
                    cannonball.y += Math.sin(cannonball.angle) * cannonball.speed * deltaTime * 0.001;
                    
                    if (cannonball.x < -10 || cannonball.x > this.canvas.width + 10 || 
                        cannonball.y < -10 || cannonball.y > this.canvas.height + 10) {
                        cannonball.dead = true;
                    }
                }
            }
            
            handleShooting() {
                const currentTime = Date.now();
                
                for (let ship of this.gameState.ships) {
                    if (currentTime - ship.lastShot >= ship.shotCooldown) {
                        this.fireCannonball(ship);
                        ship.lastShot = currentTime;
                    }
                }
            }
            
            fireCannonball(ship) {
                const cannonball = {
                    id: Math.random().toString(36).substr(2, 9),
                    x: ship.x + Math.cos(ship.cannonAngle) * 15,
                    y: ship.y + Math.sin(ship.cannonAngle) * 15,
                    angle: ship.cannonAngle,
                    speed: GAME_CONFIG.CANNONBALL_SPEED,
                    shooterId: ship.id,
                    shooterPlayerId: ship.playerId,
                    dead: false
                };
                
                this.gameState.cannonballs.push(cannonball);
                
                // Play cannon fire sound
                this.playRandomCannonSound();
            }
            
            checkCollisions() {
                // Ship-ship ramming collisions
                for (let i = 0; i < this.gameState.ships.length; i++) {
                    for (let j = i + 1; j < this.gameState.ships.length; j++) {
                        const ship1 = this.gameState.ships[i];
                        const ship2 = this.gameState.ships[j];
                        
                        if (ship1.playerId === ship2.playerId) continue;
                        
                        const dx = ship2.x - ship1.x;
                        const dy = ship2.y - ship1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 17) {
                            const ship1FrontX = ship1.x + Math.cos(ship1.angle) * 14;
                            const ship1FrontY = ship1.y + Math.sin(ship1.angle) * 14;
                            const ship2FrontX = ship2.x + Math.cos(ship2.angle) * 14;
                            const ship2FrontY = ship2.y + Math.sin(ship2.angle) * 14;
                            
                            const ship1FrontToShip2 = Math.sqrt((ship1FrontX - ship2.x) ** 2 + (ship1FrontY - ship2.y) ** 2);
                            const ship2FrontToShip1 = Math.sqrt((ship2FrontX - ship1.x) ** 2 + (ship2FrontY - ship1.y) ** 2);
                            
                            if (ship1FrontToShip2 < 12 && ship2FrontToShip1 < 12) {
                                if (ship1FrontToShip2 < ship2FrontToShip1) {
                                    if (!ship1.lastRamTime || Date.now() - ship1.lastRamTime > 2000) {
                                        ship2.health -= 1;
                                        ship1.lastRamTime = Date.now();
                                        
                                        const pushX = (dx / distance) * 20;
                                        const pushY = (dy / distance) * 20;
                                        ship2.x += pushX;
                                        ship2.y += pushY;
                                        
                                        if (ship2.health <= 0) {
                                            this.gameState.players[ship1.playerId].score++;
                                        }
                                    }
                                } else {
                                    if (!ship2.lastRamTime || Date.now() - ship2.lastRamTime > 2000) {
                                        ship1.health -= 1;
                                        ship2.lastRamTime = Date.now();
                                        
                                        const pushX = (-dx / distance) * 20;
                                        const pushY = (-dy / distance) * 20;
                                        ship1.x += pushX;
                                        ship1.y += pushY;
                                        
                                        if (ship1.health <= 0) {
                                            this.gameState.players[ship2.playerId].score++;
                                        }
                                    }
                                }
                            } else if (ship1FrontToShip2 < 12) {
                                if (!ship1.lastRamTime || Date.now() - ship1.lastRamTime > 2000) {
                                    ship2.health -= 1;
                                    ship1.lastRamTime = Date.now();
                                    
                                    const pushX = (dx / distance) * 20;
                                    const pushY = (dy / distance) * 20;
                                    ship2.x += pushX;
                                    ship2.y += pushY;
                                    
                                    if (ship2.health <= 0) {
                                        this.gameState.players[ship1.playerId].score++;
                                    }
                                }
                            } else if (ship2FrontToShip1 < 12) {
                                if (!ship2.lastRamTime || Date.now() - ship2.lastRamTime > 2000) {
                                    ship1.health -= 1;
                                    ship2.lastRamTime = Date.now();
                                    
                                    const pushX = (-dx / distance) * 20;
                                    const pushY = (-dy / distance) * 20;
                                    ship1.x += pushX;
                                    ship1.y += pushY;
                                    
                                    if (ship1.health <= 0) {
                                        this.gameState.players[ship2.playerId].score++;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Neutral ship ramming collisions with regular ships
                if (this.gameState.neutralShips) {
                    for (let neutralShip of this.gameState.neutralShips) {
                        for (let ship of this.gameState.ships) {
                            const dx = ship.x - neutralShip.x;
                            const dy = ship.y - neutralShip.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < 17) {
                                // Calculate front of neutral ship (like pirates ramming)
                                const neutralFrontX = neutralShip.x + Math.cos(neutralShip.angle) * 14;
                                const neutralFrontY = neutralShip.y + Math.sin(neutralShip.angle) * 14;
                                const neutralFrontToShip = Math.sqrt((neutralFrontX - ship.x) ** 2 + (neutralFrontY - ship.y) ** 2);
                                
                                if (neutralFrontToShip < 12) {
                                    if (!neutralShip.lastRamTime || Date.now() - neutralShip.lastRamTime > 1500) {
                                        // Neutral ship rams regular ship
                                        ship.health -= 1;
                                        neutralShip.lastRamTime = Date.now();
                                        
                                        // Push the regular ship away
                                        const pushX = (dx / distance) * 25;
                                        const pushY = (dy / distance) * 25;
                                        ship.x += pushX;
                                        ship.y += pushY;
                                        
                                        // Neutral ship bounces back slightly
                                        neutralShip.x -= pushX * 0.3;
                                        neutralShip.y -= pushY * 0.3;
                                        
                                        // Ramming collision occurred (no sound effect available)
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Ship-obstacle collisions
                for (let ship of this.gameState.ships) {
                    for (let obstacle of this.gameState.obstacles) {
                        const dx = ship.x - obstacle.x;
                        const dy = ship.y - obstacle.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < 14 + obstacle.radius) {
                            ship.x = obstacle.x + (dx / distance) * (14 + obstacle.radius);
                            ship.y = obstacle.y + (dy / distance) * (14 + obstacle.radius);
                            
                            const normal = Math.atan2(dy, dx);
                            const incidentAngle = ship.angle - normal;
                            ship.angle = normal + Math.PI - incidentAngle;
                            
                            while (ship.angle > Math.PI) ship.angle -= 2 * Math.PI;
                            while (ship.angle < -Math.PI) ship.angle += 2 * Math.PI;
                            
                            ship.speed *= 0.5;
                            ship.targetSpeed = ship.speed;
                        }
                    }
                }
                
                // Cannonball-obstacle collisions
                for (let cannonball of this.gameState.cannonballs) {
                    for (let obstacle of this.gameState.obstacles) {
                        const dx = cannonball.x - obstacle.x;
                        const dy = cannonball.y - obstacle.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < obstacle.radius) {
                            cannonball.dead = true;
                            
                            if (obstacle.destructible) {
                                obstacle.radius -= 5;
                                if (obstacle.radius <= 10) {
                                    obstacle.dead = true;
                                }
                            }
                        }
                    }
                }
                
                // Cannonball-ship collisions
                for (let cannonball of this.gameState.cannonballs) {
                    for (let ship of this.gameState.ships) {
                        if (cannonball.shooterId === ship.id) continue;
                        if (cannonball.shooterPlayerId === ship.playerId) continue;
                        
                        const dx = cannonball.x - ship.x;
                        const dy = cannonball.y - ship.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < 12) {
                            cannonball.dead = true;
                            ship.health -= 1;
                            
                            if (ship.health <= 0) {
                                // Only award points for player kills, not neutral ship kills
                                if (cannonball.shooterPlayerId !== 'neutral' && this.gameState.players[cannonball.shooterPlayerId]) {
                                    this.gameState.players[cannonball.shooterPlayerId].score++;
                                    
                                    // Award tier progression to the killer ship
                                    this.awardKillTierProgression(cannonball.shooterId, ship);
                                }
                            }
                        }
                    }
                }
                
                // Cannonball-neutral ship collisions
                if (this.gameState.neutralShips) {
                    for (let cannonball of this.gameState.cannonballs) {
                        if (cannonball.shooterType === 'neutral') continue; // Neutral ships don't hit themselves
                        
                        for (let neutralShip of this.gameState.neutralShips) {
                            const dx = cannonball.x - neutralShip.x;
                            const dy = cannonball.y - neutralShip.y;
                            const distance = Math.sqrt(dx*dx + dy*dy);
                            
                            if (distance < 12) {
                                cannonball.dead = true;
                                neutralShip.health -= 1;
                                
                                // No score points for killing neutral ships - they're neutral!
                            }
                        }
                    }
                }
                
                // Ship-power up collisions
                if (this.gameState.powerUps) {
                    for (let ship of this.gameState.ships) {
                        for (let powerUp of this.gameState.powerUps) {
                            if (powerUp.collected) continue;
                            
                            const dx = ship.x - powerUp.x;
                            const dy = ship.y - powerUp.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < 17) {
                                this.applyPowerUp(ship, powerUp);
                                powerUp.collected = true;
                                console.log(`✅ Ship ${ship.shipNumber} (${ship.playerId}) collected ${powerUp.type} power-up!`);
                            }
                        }
                    }
                }
            }
            
            cleanupDeadObjects() {
                for (let i = this.gameState.ships.length - 1; i >= 0; i--) {
                    const ship = this.gameState.ships[i];
                    if (ship.health <= 0) {
                        if (ship === this.cameraFollowShip) {
                            this.cameraFollowShip = null;
                            this.updateSelectedDisplay();
                        }
                        
                        this.gameState.players[ship.playerId].shipCount--;
                        this.gameState.ships.splice(i, 1);
                        
                        setTimeout(() => {
                            if (this.gameState.gameStarted) {
                                this.spawnShip(ship.playerId);
                            }
                        }, 2000);
                    }
                }
                
                // Clean up dead neutral ships and drop power-ups
                if (this.gameState.neutralShips) {
                    for (let i = this.gameState.neutralShips.length - 1; i >= 0; i--) {
                        const neutralShip = this.gameState.neutralShips[i];
                        if (neutralShip.health <= 0) {
                            // Drop power-up when neutral ship dies
                            this.dropPowerUp(neutralShip.x, neutralShip.y);
                            this.gameState.neutralShips.splice(i, 1);
                        }
                    }
                }
                
                this.gameState.cannonballs = this.gameState.cannonballs.filter(c => !c.dead);
                this.gameState.obstacles = this.gameState.obstacles.filter(o => !o.dead);
            }
            
            updateGameStatus() {
                const blueShips = this.gameState.ships.filter(s => s.playerId === 'blue').length;
                const redShips = this.gameState.ships.filter(s => s.playerId === 'red').length;
                
                if (this.gameState.gameStartTime) {
                    let elapsed = Math.floor((Date.now() - this.gameState.gameStartTime - this.gameState.totalPausedTime) / 1000);
                    
                    if (this.gameState.gamePaused && this.gameState.pauseStartTime) {
                        elapsed -= Math.floor((Date.now() - this.gameState.pauseStartTime) / 1000);
                    }
                    
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('gameTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
                
                if (this.gameState.players.blue.score >= 15) {
                    this.gameState.gameStarted = false;
                    this.clearAllSpawnTimeouts();
                    document.getElementById('menuTitle').textContent = 'Blue AI Wins!';
                    document.getElementById('menuContent').innerHTML = `
                        <button id="startBtn">Start New Demo</button>
                        <button id="resetBtn">Reset Demo</button>
                        <button onclick="window.location.href='/'">← Main Menu</button>
                    `;
                    this.setupControls();
                    document.getElementById('gameMenu').classList.remove('hidden');
                } else if (this.gameState.players.red.score >= 15) {
                    this.gameState.gameStarted = false;
                    this.clearAllSpawnTimeouts();
                    document.getElementById('menuTitle').textContent = 'Red AI Wins!';
                    document.getElementById('menuContent').innerHTML = `
                        <button id="startBtn">Start New Demo</button>
                        <button id="resetBtn">Reset Demo</button>
                        <button onclick="window.location.href='/'">← Main Menu</button>
                    `;
                    this.setupControls();
                    document.getElementById('gameMenu').classList.remove('hidden');
                }
                
                document.getElementById('blueScore').textContent = this.gameState.players.blue.score;
                document.getElementById('redScore').textContent = this.gameState.players.red.score;
            }
            
            getAIDebugInfo(ship) {
                if (!ship.aiTarget) return { behavior: 'No Target', reason: 'Searching for enemies' };
                
                const target = ship.aiTarget;
                const distance = Math.sqrt((target.x - ship.x) ** 2 + (target.y - ship.y) ** 2);
                
                // Determine AI behavior based on current actions
                let behavior = 'Unknown';
                let reason = '';
                let targetInfo = '';
                
                if (target) {
                    targetInfo = `Target: ${target.playerId} Ship ${target.shipNumber || '?'}`;
                }
                
                // Check current speed and direction to determine behavior
                const speedRatio = ship.targetSpeed / 50; // Assuming max speed ~50
                const angleToTarget = Math.atan2(target.y - ship.y, target.x - ship.x);
                const angleDiff = Math.abs(ship.angle - angleToTarget);
                
                if (distance > 150) {
                    behavior = 'PURSUING';
                    reason = `Closing distance (${Math.round(distance)}px)`;
                } else if (distance < 80) {
                    behavior = 'EVADING';
                    reason = `Too close, backing off`;
                } else if (angleDiff > Math.PI/4) {
                    behavior = 'MANEUVERING';
                    reason = 'Positioning for attack';
                } else {
                    behavior = 'ATTACKING';
                    reason = 'In firing position';
                }
                
                // Check for obstacle avoidance
                const obstacles = this.gameState.obstacles || [];
                for (let obstacle of obstacles) {
                    const obstacleDistance = Math.sqrt((obstacle.x - ship.x) ** 2 + (obstacle.y - ship.y) ** 2);
                    if (obstacleDistance < 100) {
                        behavior = 'AVOIDING';
                        reason = 'Dodging obstacle';
                        break;
                    }
                }
                
                return {
                    behavior,
                    reason,
                    targetInfo,
                    distance: Math.round(distance),
                    speed: Math.round(ship.speed),
                    targetSpeed: Math.round(ship.targetSpeed),
                    rudderAngle: Math.round(ship.rudderAngle * 180 / Math.PI)
                };
            }
            
            renderHeadingDisplay() {
                // Render blue team dashboard
                this.renderTeamDashboard(this.blueCtx, this.blueCanvas, this.blueSelectedShip, '#4169E1');
                
                // Render red team dashboard
                this.renderTeamDashboard(this.redCtx, this.redCanvas, this.redSelectedShip, '#DC143C');
            }
            
            renderTeamDashboard(ctx, canvas, ship, teamColor) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (!ship) {
                    ctx.fillStyle = '#666';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No ship selected', canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                const tillerAngle = ship.rudderAngle;
                const degrees = Math.round(tillerAngle * 180 / Math.PI);
                const aiInfo = this.getAIDebugInfo(ship);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height - 15;
                const radius = 60;
                
                // Draw tiller gauge
                ctx.strokeStyle = teamColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, Math.PI, 0);
                ctx.stroke();
                
                // Draw tick marks
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Major ticks
                for (let tillerDeg = -45; tillerDeg <= 45; tillerDeg += 15) {
                    const protractorAngle = Math.PI * (1 - (tillerDeg + 45) / 90);
                    
                    const x1 = centerX + Math.cos(protractorAngle) * (radius - 10);
                    const y1 = centerY - Math.sin(protractorAngle) * (radius - 10);
                    const x2 = centerX + Math.cos(protractorAngle) * radius;
                    const y2 = centerY - Math.sin(protractorAngle) * radius;
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
                
                // Draw tiller indicator
                const tillerDegrees = tillerAngle * 180 / Math.PI;
                const clampedTiller = Math.max(-45, Math.min(45, tillerDegrees));
                const protractorAngle = Math.PI * (1 - (clampedTiller + 45) / 90);
                
                const indicatorX = centerX + Math.cos(protractorAngle) * (radius - 5);
                const indicatorY = centerY - Math.sin(protractorAngle) * (radius - 5);
                
                ctx.strokeStyle = teamColor;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(indicatorX, indicatorY);
                ctx.stroke();
                
                ctx.fillStyle = teamColor;
                ctx.beginPath();
                ctx.arc(indicatorX, indicatorY, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw center point
                ctx.fillStyle = teamColor;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Display compact AI info
                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                
                // Behavior at top
                ctx.fillStyle = aiInfo.behavior === 'ATTACKING' ? '#ff4444' : 
                               aiInfo.behavior === 'PURSUING' ? '#ffaa44' :
                               aiInfo.behavior === 'EVADING' ? '#44ff44' :
                               aiInfo.behavior === 'AVOIDING' ? '#ff44ff' : '#4444ff';
                ctx.font = 'bold 11px Arial';
                ctx.fillText(aiInfo.behavior, centerX, 5);
                
                // Speed and rudder info
                ctx.fillStyle = '#ccc';
                ctx.font = '9px Arial';
                ctx.fillText(`Speed: ${aiInfo.speed}`, centerX, 20);
                ctx.fillText(`Rudder: ${degrees}°`, centerX, 32);
            }
            
            resetGame() {
                this.clearAllSpawnTimeouts();
                
                // Pause background music when resetting
                this.pauseBackgroundMusic();
                
                this.gameState = {
                    ships: [],
                    cannonballs: [],
                    obstacles: [],
                    neutralShips: [],
                    powerUps: [],
                    players: {
                        blue: { score: 0, dock: { x: 100, y: 620, spawnAngle: -45 * Math.PI/180 }, shipCount: 0, aiType: 'balanced', difficulty: 'HARD' }, // Will be updated by generateRandomSpawnPoints
                        red: { score: 0, dock: { x: 900, y: 80, spawnAngle: 135 * Math.PI/180 }, shipCount: 0, aiType: 'balanced', difficulty: 'HARD' } // Will be updated by generateRandomSpawnPoints
                    },
                    selectedObject: null,
                    selectedObjectType: null,
                    gameStarted: false,
                    gamePaused: false,
                    gameStartTime: null,
                    countdown: 0,
                    countdownActive: false,
                    pauseStartTime: null,
                    totalPausedTime: 0,
                    audio: {
                        musicEnabled: true,
                        musicVolume: 0.5,
                        musicStarted: false,
                        soundEnabled: true,
                        soundVolume: 0.7,
                        cannonSounds: []
                    }
                };
                
                this.blueAISelectedShipIndex = 0;
                this.redAISelectedShipIndex = 0;
                this.lastIcebergSpawn = 0;
                this.lastNeutralSpawn = 0;
                this.cameraFollowShip = null;
                this.generateRandomSpawnPoints();
                this.generateObstacles();
                document.getElementById('menuTitle').textContent = 'Naval Battle Demo';
                document.getElementById('menuContent').innerHTML = `
                    <button id="startBtn">Start Demo</button>
                    <button id="resetBtn">Reset Demo</button>
                    <button onclick="window.location.href='/'">← Main Menu</button>
                `;
                this.setupControls();
                document.getElementById('gameMenu').classList.remove('hidden');
            }
            
            resizeCanvas() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                this.canvas.width = width;
                this.canvas.height = height;
                
                // Calculate scaling based on viewport size compared to original 1000x700
                const scaleX = width / 1000;
                const scaleY = height / 700;
                this.SCALE_AVG = (scaleX + scaleY) / 2;
                
                console.log(`Canvas resized to ${width}x${height}, scale factor: ${this.SCALE_AVG.toFixed(2)}`);
                
                // Update game config canvas dimensions
                GAME_CONFIG.CANVAS_WIDTH = width;
                GAME_CONFIG.CANVAS_HEIGHT = height;
            }
            
            toggleSpeed() {
                if (this.speedMultiplier === 1) {
                    this.speedMultiplier = 2;
                    document.getElementById('speedBtn').textContent = 'Speed: 2x';
                } else if (this.speedMultiplier === 2) {
                    this.speedMultiplier = 3;
                    document.getElementById('speedBtn').textContent = 'Speed: 3x';
                } else {
                    this.speedMultiplier = 1;
                    document.getElementById('speedBtn').textContent = 'Speed: 1x';
                }
            }
            
            toggleDashboard() {
                const dashboard = document.getElementById('dualDashboardContainer');
                const toggleBtn = document.getElementById('dashboardToggle');
                
                dashboard.classList.toggle('hidden');
                
                if (dashboard.classList.contains('hidden')) {
                    toggleBtn.textContent = 'Show Dashboard';
                } else {
                    toggleBtn.textContent = 'Hide Dashboard';
                }
            }
            
            renderAnimatedOcean() {
                const time = Date.now() * 0.001; // Convert to seconds for wave animation
                
                // Base ocean color
                this.ctx.fillStyle = "#0f3460";
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Create animated wave patterns with depth
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, "#1e4a6f");
                gradient.addColorStop(0.3, "#0f3460");
                gradient.addColorStop(0.7, "#0a2847");
                gradient.addColorStop(1, "#051c2f");
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                
                // Draw animated wave lines
                this.ctx.strokeStyle = "rgba(32, 178, 170, 0.05)"; // Much more transparent
                this.ctx.lineWidth = 1;
                
                for (let i = 0; i < 8; i++) {
                    this.ctx.beginPath();
                    const waveOffset = time * (2 + i * 0.3); // Much slower waves
                    const amplitude = 8 + i * 2; // Smaller waves
                    const frequency = 0.003 + i * 0.0005; // Lower frequency
                    
                    for (let x = 0; x <= this.canvas.width; x += 5) {
                        const y = this.canvas.height * (0.2 + i * 0.1) + 
                                 Math.sin((x * frequency) + waveOffset) * amplitude;
                        if (x === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    this.ctx.stroke();
                }
                
                // Draw occasional sea birds
                this.drawSeaBirds(time);
                
                // Draw floating debris and seaweed patches
                this.drawFloatingDebris(time);
                
                // Add subtle floating particles/bubbles
                this.ctx.fillStyle = "rgba(135, 206, 235, 0.1)";
                for (let i = 0; i < 15; i++) {
                    const particleTime = time * (0.1 + i * 0.02); // Much slower particles
                    const x = (i * 73 + Math.sin(particleTime) * 15) % this.canvas.width; // Smaller movement
                    const y = (i * 47 + Math.cos(particleTime * 0.7) * 10) % this.canvas.height; // Smaller movement
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 2 + Math.sin(particleTime * 2) * 1, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Animated ocean background
                this.renderAnimatedOcean();
                
                // Render obstacles
                for (let obstacle of this.gameState.obstacles) {
                    this.ctx.save();
                    this.ctx.translate(obstacle.x, obstacle.y);
                    
                    // Draw elevation shadow first (proportional to obstacle size)
                    const shadowOffset = obstacle.radius * 0.25;
                    const shadowRadius = obstacle.radius * 0.8;
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    this.ctx.beginPath();
                    this.ctx.ellipse(shadowOffset, shadowOffset, shadowRadius, shadowRadius * 0.5, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    if (obstacle.type === 'island') {
                        // Draw island image
                        const islandImg = this.getIslandImage(obstacle.imageIndex);
                        if (islandImg) {
                            const size = obstacle.radius * 2;
                            this.ctx.drawImage(islandImg, -size/2, -size/2, size, size);
                        }
                    } else if (obstacle.type === 'iceberg') {
                        // Draw iceberg image
                        const icebergImg = this.getIcebergImage(obstacle.imageIndex);
                        if (icebergImg) {
                            const size = obstacle.radius * 2;
                            this.ctx.drawImage(icebergImg, -size/2, -size/2, size, size);
                        }
                    }
                    
                    this.ctx.restore();
                }
                
                // Render docks
                const blueDock = this.gameState.players.blue.dock;
                const redDock = this.gameState.players.red.dock;
                
                // Blue dock
                this.ctx.save();
                this.ctx.fillStyle = 'rgba(65, 105, 225, 0.4)';
                this.ctx.beginPath();
                this.ctx.arc(blueDock.x, blueDock.y, Math.round(35 * this.SCALE_AVG), 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.fillStyle = '#4169E1';
                this.ctx.beginPath();
                this.ctx.arc(blueDock.x, blueDock.y, Math.round(25 * this.SCALE_AVG), 0, Math.PI * 2);
                this.ctx.fill();
                
                // Red dock
                this.ctx.fillStyle = 'rgba(220, 20, 60, 0.4)';
                this.ctx.beginPath();
                this.ctx.arc(redDock.x, redDock.y, Math.round(35 * this.SCALE_AVG), 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.fillStyle = '#DC143C';
                this.ctx.beginPath();
                this.ctx.arc(redDock.x, redDock.y, Math.round(25 * this.SCALE_AVG), 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.restore();
                
                // Render ships
                for (let ship of this.gameState.ships) {
                    // Draw wake effect behind moving ships
                    if (ship.vx || ship.vy) {
                        const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
                        if (speed > 0.5) { // Only draw wake for ships moving fast enough
                            this.drawShipWake(ship, speed);
                        }
                    }
                    
                    this.ctx.save();
                    this.ctx.translate(ship.x, ship.y);
                    
                    // Draw ship shadow first
                    const shadowOffset = 5;
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    this.ctx.beginPath();
                    this.ctx.ellipse(shadowOffset, shadowOffset, 20, 12, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw ship image based on playerId and angle
                    const shipImg = this.getShipImage(ship.playerId, ship.angle);
                    if (shipImg) {
                        // Draw ship image centered at origin (scaled for higher resolution)
                        const shipSize = 60; // Reduced to 60px
                        console.log('Drawing ship with size:', shipSize); // Debug
                        this.ctx.drawImage(shipImg, -shipSize/2, -shipSize/2, shipSize, shipSize);
                    } else {
                        // Fallback to colored rectangles if image not loaded
                        let fillColor, darkColor;
                        if (ship.playerId === 'blue') {
                            fillColor = '#4169E1';
                            darkColor = '#00008B';
                        } else if (ship.playerId === 'red') {
                            fillColor = '#DC143C';
                            darkColor = '#8B0000';
                        } else {
                            // Neutral ships - use white/gray
                            fillColor = '#FFFFFF';
                            darkColor = '#CCCCCC';
                        }
                        
                        const scaledHalfSize = 30; // Half of 60px
                        const scaledSize = 60; // 60px total size
                        console.log('Drawing rectangle ship with size:', scaledSize); // Debug
                        
                        this.ctx.fillStyle = fillColor;
                        this.ctx.fillRect(-scaledHalfSize, -scaledHalfSize, scaledSize, scaledSize);
                        
                        this.ctx.fillStyle = darkColor;
                        this.ctx.fillRect(scaledHalfSize/2, -scaledHalfSize/2, scaledHalfSize/2, scaledHalfSize);
                        
                        this.ctx.strokeStyle = '#000';
                        this.ctx.lineWidth = Math.round(1 * this.SCALE_AVG);
                        this.ctx.strokeRect(-scaledHalfSize, -scaledHalfSize, scaledSize, scaledSize);
                    }
                    
                    // Show selection for both AI team selected ships (while in ship coordinate space)
                    if (ship === this.blueSelectedShip || ship === this.redSelectedShip) {
                        // Enhanced selection highlighting
                        this.ctx.strokeStyle = '#FFFF00';
                        this.ctx.lineWidth = 4;
                        this.ctx.strokeRect(-24, -24, 48, 48);
                        
                        // Add a pulsing outer glow effect
                        const time = Date.now() / 500;
                        const alpha = 0.3 + 0.2 * Math.sin(time);
                        this.ctx.shadowColor = '#FFFF00';
                        this.ctx.shadowBlur = 10;
                        this.ctx.globalAlpha = alpha;
                        this.ctx.strokeStyle = '#FFFFFF';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(-30, -30, 60, 60);
                        this.ctx.shadowBlur = 0;
                        this.ctx.globalAlpha = 1;
                    }
                    
                    this.ctx.restore();
                    
                    // Small stars removed to avoid duplication
                    
                    // Tier display removed - now using stars only
                    
                    // Large gold stars for tier 2+ ships
                    if (ship.tier && ship.tier > 1) {
                        this.ctx.save();
                        this.ctx.translate(ship.x, ship.y - 65);
                        
                        const starCount = Math.min(ship.tier - 1, 3);
                        const starSize = 10;  // Much larger stars
                        const spacing = 25;   // More spacing
                        const startX = -(starCount - 1) * spacing / 2;
                        
                        for (let i = 0; i < starCount; i++) {
                            const x = startX + i * spacing;
                            
                            // Draw large filled circle as "star"
                            this.ctx.fillStyle = '#FFD700';
                            this.ctx.beginPath();
                            this.ctx.arc(x, 0, starSize, 0, Math.PI * 2);
                            this.ctx.fill();
                            
                            // Thick black border
                            this.ctx.strokeStyle = '#000';
                            this.ctx.lineWidth = 3;
                            this.ctx.stroke();
                            
                            // Add inner white dot for visibility
                            this.ctx.fillStyle = '#FFFFFF';
                            this.ctx.beginPath();
                            this.ctx.arc(x, 0, 3, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        this.ctx.restore();
                    }
                    
                    // Large upgrade indicators in a box next to ship
                    if (ship.upgrades) {
                        this.ctx.save();
                        this.ctx.translate(ship.x + 25, ship.y - 15);
                        
                        const symbols = [];
                        if (ship.upgrades.health > 0) symbols.push({text: `♥${ship.upgrades.health}`, color: '#00FF00'});
                        if (ship.upgrades.damage > 0) symbols.push({text: `⚡${ship.upgrades.damage}`, color: '#FF4444'});
                        if (ship.upgrades.rateOfFire > 0) symbols.push({text: `⟲${ship.upgrades.rateOfFire}`, color: '#FFFF00'});
                        if (ship.upgrades.speed > 0) symbols.push({text: `→${ship.upgrades.speed}`, color: '#44AAFF'});
                        
                        if (symbols.length > 0) {
                            // Draw background box
                            const boxWidth = symbols.length * 20 + 10;
                            const boxHeight = 20;
                            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            this.ctx.fillRect(-5, -15, boxWidth, boxHeight);
                            this.ctx.strokeStyle = '#FFFFFF';
                            this.ctx.lineWidth = 2;
                            this.ctx.strokeRect(-5, -15, boxWidth, boxHeight);
                            
                            // Draw symbols with colors
                            this.ctx.font = `bold ${Math.round(14 * this.SCALE_AVG)}px Arial`;  // Large font (scaled)
                            this.ctx.textAlign = 'center';
                            this.ctx.lineWidth = 2;
                            
                            for (let i = 0; i < symbols.length; i++) {
                                const x = i * 20 + 10;
                                this.ctx.fillStyle = symbols[i].color;
                                this.ctx.strokeStyle = '#000';
                                this.ctx.strokeText(symbols[i].text, x, -2);
                                this.ctx.fillText(symbols[i].text, x, -2);
                            }
                        }
                        
                        this.ctx.restore();
                    }
                    
                    // Health bar (visible for all ships in demo mode for educational purposes)
                    this.ctx.save();
                    this.ctx.translate(ship.x, ship.y - 20);
                    
                    const healthRatio = ship.health / ship.maxHealth;
                    
                    // Health bar background (larger and more visible)
                    const healthBarWidth = GAME_CONFIG.HEALTH_BAR_WIDTH;
                    const healthBarHeight = GAME_CONFIG.HEALTH_BAR_HEIGHT;
                    
                    this.ctx.fillStyle = '#333';
                    this.ctx.fillRect(-healthBarWidth/2, 0, healthBarWidth, healthBarHeight);
                    
                    // Health bar
                    this.ctx.fillStyle = healthRatio > 0.66 ? '#00FF00' : healthRatio > 0.33 ? '#FFFF00' : '#FF0000';
                    this.ctx.fillRect(-healthBarWidth/2, 0, healthRatio * healthBarWidth, healthBarHeight);
                    
                    // Health bar border
                    this.ctx.strokeStyle = '#000';
                    this.ctx.lineWidth = Math.round(1 * this.SCALE_AVG);
                    this.ctx.strokeRect(-healthBarWidth/2, 0, healthBarWidth, healthBarHeight);
                    
                    this.ctx.restore();
                }
                
                // Render ship numbers
                for (let ship of this.gameState.ships) {
                    if (ship.shipNumber) {
                        const numberX = ship.x - 15;
                        const numberY = ship.y + 15;
                        
                        this.ctx.save();
                        
                        // Make selected ship numbers larger and more prominent
                        const isSelected = ship === this.blueSelectedShip || ship === this.redSelectedShip;
                        const fontSize = isSelected ? 24 : 18;
                        let fillColor = ship.playerId === 'blue' ? '#4169E1' : '#DC143C';
                        if (isSelected) {
                            // Keep team color but make it brighter
                            fillColor = ship.playerId === 'blue' ? '#6495ED' : '#FF6B6B';
                        }
                        const strokeWidth = isSelected ? 3 : 2;
                        
                        this.ctx.fillStyle = fillColor;
                        this.ctx.strokeStyle = '#000';
                        this.ctx.lineWidth = strokeWidth;
                        this.ctx.font = `bold ${fontSize}px Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        
                        this.ctx.strokeText(ship.shipNumber.toString(), numberX, numberY);
                        this.ctx.fillText(ship.shipNumber.toString(), numberX, numberY);
                        
                        this.ctx.restore();
                    }
                }
                
                // Render cannon directions
                for (let ship of this.gameState.ships) {
                    const color = ship.playerId === 'blue' ? '#0000FF' : '#FF0000';
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(ship.x, ship.y);
                    this.ctx.lineTo(
                        ship.x + Math.cos(ship.cannonAngle) * 50,
                        ship.y + Math.sin(ship.cannonAngle) * 50
                    );
                    this.ctx.stroke();
                }
                
                // Render neutral ships
                if (this.gameState.neutralShips && this.gameState.neutralShips.length > 0) {
                    for (let neutralShip of this.gameState.neutralShips) {
                        this.ctx.save();
                        this.ctx.translate(neutralShip.x, neutralShip.y);
                        
                        // Draw neutral ship image based on angle
                        const shipImg = this.getShipImage('neutral', neutralShip.angle);
                        if (shipImg) {
                            // Draw ship image centered at origin (scaled)
                            const shipSize = 60; // Reduced to 60px
                            console.log('Drawing neutral ship with size:', shipSize); // Debug
                            this.ctx.drawImage(shipImg, -shipSize/2, -shipSize/2, shipSize, shipSize);
                        } else {
                            // Fallback to colored rectangles if image not loaded
                            const scaledHalfSize = 30; // Half of 60px
                            const scaledSize = 60; // 60px total size
                            console.log('Drawing neutral rectangle ship with size:', scaledSize); // Debug
                            this.ctx.fillStyle = '#FFFFFF';
                            this.ctx.fillRect(-scaledHalfSize, -scaledHalfSize, scaledSize, scaledSize);
                            
                            this.ctx.fillStyle = '#CCCCCC';
                            this.ctx.fillRect(scaledHalfSize/2, -scaledHalfSize/2, scaledHalfSize/2, scaledHalfSize);
                            
                            this.ctx.strokeStyle = '#000';
                            this.ctx.lineWidth = Math.round(1 * this.SCALE_AVG);
                            this.ctx.strokeRect(-scaledHalfSize, -scaledHalfSize, scaledSize, scaledSize);
                        }
                        
                        this.ctx.restore();
                        
                        // Render cannon direction for neutral ships
                        if (neutralShip.aiTarget) {
                            const dx = neutralShip.aiTarget.x - neutralShip.x;
                            const dy = neutralShip.aiTarget.y - neutralShip.y;
                            const cannonAngle = Math.atan2(dy, dx);
                            
                            this.ctx.strokeStyle = '#FFFFFF';
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.moveTo(neutralShip.x, neutralShip.y);
                            this.ctx.lineTo(
                                neutralShip.x + Math.cos(cannonAngle) * 40,
                                neutralShip.y + Math.sin(cannonAngle) * 40
                            );
                            this.ctx.stroke();
                        }
                        
                        // Health bar for neutral ships
                        if (neutralShip.health < neutralShip.maxHealth) {
                            this.ctx.save();
                            this.ctx.translate(neutralShip.x, neutralShip.y - 20);
                            
                            const healthRatio = neutralShip.health / neutralShip.maxHealth;
                            
                            this.ctx.fillStyle = '#333';
                            this.ctx.fillRect(-10, 0, 20, 4);
                            
                            this.ctx.fillStyle = healthRatio > 0.5 ? '#00FF00' : '#FFFF00';
                            this.ctx.fillRect(-10, 0, healthRatio * 20, 4);
                            
                            this.ctx.strokeStyle = '#000';
                            this.ctx.lineWidth = 1;
                            this.ctx.strokeRect(-10, 0, 20, 4);
                            
                            this.ctx.restore();
                        }
                    }
                }
                
                // Render neutral ship numbers
                if (this.gameState.neutralShips) {
                    for (let neutralShip of this.gameState.neutralShips) {
                        if (neutralShip.shipNumber) {
                            const numberX = neutralShip.x - 15;
                            const numberY = neutralShip.y + 15;
                            
                            this.ctx.save();
                            
                            this.ctx.fillStyle = '#FFFFFF';
                            this.ctx.strokeStyle = '#000';
                            this.ctx.lineWidth = 2;
                            this.ctx.font = `bold ${Math.round(18 * this.SCALE_AVG)}px Arial`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            
                            this.ctx.strokeText(neutralShip.shipNumber.toString(), numberX, numberY);
                            this.ctx.fillText(neutralShip.shipNumber.toString(), numberX, numberY);
                            
                            this.ctx.restore();
                        }
                    }
                }
                
                // Render power-ups
                if (this.gameState.powerUps) {
                    for (let powerUp of this.gameState.powerUps) {
                        if (powerUp.collected) continue;
                        
                        this.ctx.save();
                        this.ctx.translate(powerUp.x, powerUp.y);
                        
                        // Power-up background
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, 12, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Power-up icon
                        this.ctx.fillStyle = this.getPowerUpColor(powerUp.type);
                        this.ctx.strokeStyle = '#000';
                        this.ctx.lineWidth = 2;
                        this.ctx.font = `bold ${Math.round(14 * this.SCALE_AVG)}px Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        
                        const icon = this.getPowerUpIcon(powerUp.type);
                        this.ctx.strokeText(icon, 0, 0);
                        this.ctx.fillText(icon, 0, 0);
                        
                        this.ctx.restore();
                    }
                }
                
                // Render cannonballs
                for (let cannonball of this.gameState.cannonballs) {
                    this.ctx.fillStyle = '#1a1a1a';
                    this.ctx.beginPath();
                    this.ctx.arc(cannonball.x, cannonball.y, Math.round(4 * this.SCALE_AVG), 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = Math.round(1 * this.SCALE_AVG);
                    this.ctx.stroke();
                }
            }
            
            getPowerUpColor(type) {
                switch (type) {
                    case 'health': return '#00FF00';
                    case 'damage': return '#FF4444';
                    case 'rateOfFire': return '#FFFF00';
                    case 'speed': return '#44AAFF';
                    default: return '#FFFFFF';
                }
            }
            
            getPowerUpIcon(type) {
                switch (type) {
                    case 'health': return '+';
                    case 'damage': return '⚡';
                    case 'rateOfFire': return '⟲';
                    case 'speed': return '→';
                    default: return '?';
                }
            }
            
            drawStar(ctx, x, y, radius) {
                const spikes = 5;
                const outerRadius = radius;
                const innerRadius = radius * 0.4;
                
                ctx.beginPath();
                
                for (let i = 0; i < spikes * 2; i++) {
                    const angle = (i * Math.PI) / spikes;
                    const r = i % 2 === 0 ? outerRadius : innerRadius;
                    const px = x + Math.cos(angle) * r;
                    const py = y + Math.sin(angle) * r;
                    
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            gameLoop() {
                const currentTime = performance.now();
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                // Only update game state if not paused
                if (!this.gameState.gamePaused) {
                    this.update(deltaTime);
                }
                
                                   // Update animation frame every 0.25 seconds (250ms)
                   if (currentTime - this.lastAnimationUpdate >= 250) {
                     this.animationFrame = (this.animationFrame + 1) % 4; // Cycle through 0, 1, 2, 3
                     this.lastAnimationUpdate = currentTime;
                   }
                
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        window.addEventListener('load', () => {
            new NavalBattleDemo();
        });
    </script>
</body>
</html>